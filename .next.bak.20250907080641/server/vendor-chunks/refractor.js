"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/refractor";
exports.ids = ["vendor-chunks/refractor"];
exports.modules = {

/***/ "(ssr)/./node_modules/refractor/lib/core.js":
/*!********************************************!*\
  !*** ./node_modules/refractor/lib/core.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   refractor: () => (/* binding */ refractor)\n/* harmony export */ });\n/* harmony import */ var hastscript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hastscript */ \"(ssr)/./node_modules/hastscript/lib/index.js\");\n/* harmony import */ var parse_entities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! parse-entities */ \"(ssr)/./node_modules/parse-entities/lib/index.js\");\n/* harmony import */ var _prism_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./prism-core.js */ \"(ssr)/./node_modules/refractor/lib/prism-core.js\");\n/**\n * @import {Element, Root, Text} from 'hast'\n * @import {Grammar, Languages} from 'prismjs'\n */\n\n/**\n * @typedef _Token\n *   Hidden Prism token.\n * @property {string} alias\n *   Alias.\n * @property {string} content\n *   Content.\n * @property {number} length\n *   Length.\n * @property {string} type\n *   Type.\n */\n\n/**\n * @typedef _Env\n *   Hidden Prism environment.\n * @property {Record<string, string>} attributes\n *   Attributes.\n * @property {Array<string>} classes\n *   Classes.\n * @property {Array<Element | Text> | Element | Text} content\n *   Content.\n * @property {string} language\n *   Language.\n * @property {string} tag\n *   Tag.\n * @property {string} type\n *   Type.\n */\n\n/**\n * @typedef {((prism: Refractor) => undefined | void) & {aliases?: Array<string> | undefined, displayName: string}} Syntax\n *   Refractor syntax function.\n */\n\n/**\n * @typedef Refractor\n *   Virtual syntax highlighting\n * @property {typeof alias} alias\n * @property {Languages} languages\n * @property {typeof listLanguages} listLanguages\n * @property {typeof highlight} highlight\n * @property {typeof registered} registered\n * @property {typeof register} register\n */\n\n// Load all stuff in `prism.js` itself, except for `prism-file-highlight.js`.\n// The wrapped non-leaky grammars are loaded instead of Prismâ€™s originals.\n\n\n\n\n// Inherit.\nfunction Refractor() {}\n\nRefractor.prototype = _prism_core_js__WEBPACK_IMPORTED_MODULE_0__.Prism\n\n/** @type {Refractor} */\n// @ts-expect-error: TS is wrong.\nconst refractor = new Refractor()\n\n// Create.\nrefractor.highlight = highlight\nrefractor.register = register\nrefractor.alias = alias\nrefractor.registered = registered\nrefractor.listLanguages = listLanguages\n\n// @ts-expect-error Overwrite Prism.\nrefractor.util.encode = encode\n// @ts-expect-error Overwrite Prism.\nrefractor.Token.stringify = stringify\n\n/**\n * Highlight `value` (code) as `language` (programming language).\n *\n * @param {string} value\n *   Code to highlight.\n * @param {Grammar | string} language\n *   Programming language name, alias, or grammar.\n * @returns {Root}\n *   Node representing highlighted code.\n */\nfunction highlight(value, language) {\n  if (typeof value !== 'string') {\n    throw new TypeError('Expected `string` for `value`, got `' + value + '`')\n  }\n\n  /** @type {Grammar} */\n  let grammar\n  /** @type {string | undefined} */\n  let name\n\n  // `name` is a grammar object.\n  // This was called internally by Prism.js before 1.28.0.\n  /* c8 ignore next 2 */\n  if (language && typeof language === 'object') {\n    grammar = language\n  } else {\n    name = language\n\n    if (typeof name !== 'string') {\n      throw new TypeError('Expected `string` for `name`, got `' + name + '`')\n    }\n\n    if (Object.hasOwn(refractor.languages, name)) {\n      grammar = refractor.languages[name]\n    } else {\n      throw new Error('Unknown language: `' + name + '` is not registered')\n    }\n  }\n\n  return {\n    type: 'root',\n    // @ts-expect-error: we hacked Prism to accept and return the things we want.\n    children: _prism_core_js__WEBPACK_IMPORTED_MODULE_0__.Prism.highlight.call(refractor, value, grammar, name)\n  }\n}\n\n/**\n * Register a syntax.\n *\n * @param {Syntax} syntax\n *   Language function made for refractor, as in, the files in\n *   `refractor/lang/*.js`.\n * @returns {undefined}\n *   Nothing.\n */\nfunction register(syntax) {\n  if (typeof syntax !== 'function' || !syntax.displayName) {\n    throw new Error('Expected `function` for `syntax`, got `' + syntax + '`')\n  }\n\n  // Do not duplicate registrations.\n  if (!Object.hasOwn(refractor.languages, syntax.displayName)) {\n    syntax(refractor)\n  }\n}\n\n/**\n * Register aliases for already registered languages.\n *\n * @param {Record<string, ReadonlyArray<string> | string> | string} language\n *   Language to alias.\n * @param {ReadonlyArray<string> | string | null | undefined} [alias]\n *   Aliases.\n * @returns {undefined}\n *   Nothing.\n */\nfunction alias(language, alias) {\n  const languages = refractor.languages\n  /** @type {Record<string, ReadonlyArray<string> | string>} */\n  let map = {}\n\n  if (typeof language === 'string') {\n    if (alias) {\n      map[language] = alias\n    }\n  } else {\n    map = language\n  }\n\n  /** @type {string} */\n  let key\n\n  for (key in map) {\n    if (Object.hasOwn(map, key)) {\n      const value = map[key]\n      const list = typeof value === 'string' ? [value] : value\n      let index = -1\n\n      while (++index < list.length) {\n        languages[list[index]] = languages[key]\n      }\n    }\n  }\n}\n\n/**\n * Check whether an `alias` or `language` is registered.\n *\n * @param {string} aliasOrLanguage\n *   Language or alias to check.\n * @returns {boolean}\n *   Whether the language is registered.\n */\nfunction registered(aliasOrLanguage) {\n  if (typeof aliasOrLanguage !== 'string') {\n    throw new TypeError(\n      'Expected `string` for `aliasOrLanguage`, got `' + aliasOrLanguage + '`'\n    )\n  }\n\n  return Object.hasOwn(refractor.languages, aliasOrLanguage)\n}\n\n/**\n * List all registered languages (names and aliases).\n *\n * @returns {Array<string>}\n *   List of language names.\n */\nfunction listLanguages() {\n  const languages = refractor.languages\n  /** @type {Array<string>} */\n  const list = []\n  /** @type {string} */\n  let language\n\n  for (language in languages) {\n    if (\n      Object.hasOwn(languages, language) &&\n      typeof languages[language] === 'object'\n    ) {\n      list.push(language)\n    }\n  }\n\n  return list\n}\n\n/**\n * @param {Array<_Token | string> | _Token | string} value\n *   Token to stringify.\n * @param {string} language\n *   Language of the token.\n * @returns {Array<Element | Text> | Element | Text}\n *   Node representing the token.\n */\nfunction stringify(value, language) {\n  if (typeof value === 'string') {\n    return {type: 'text', value}\n  }\n\n  if (Array.isArray(value)) {\n    /** @type {Array<Element | Text>} */\n    const result = []\n    let index = -1\n\n    while (++index < value.length) {\n      if (\n        value[index] !== null &&\n        value[index] !== undefined &&\n        value[index] !== ''\n      ) {\n        // Cast because we assume no sub-arrays.\n        result.push(\n          /** @type {Element | Text} */ (stringify(value[index], language))\n        )\n      }\n    }\n\n    return result\n  }\n\n  /** @type {_Env} */\n  const env = {\n    attributes: {},\n    classes: ['token', value.type],\n    content: stringify(value.content, language),\n    language,\n    tag: 'span',\n    type: value.type\n  }\n\n  if (value.alias) {\n    env.classes.push(\n      ...(typeof value.alias === 'string' ? [value.alias] : value.alias)\n    )\n  }\n\n  // @ts-expect-error Prism.\n  refractor.hooks.run('wrap', env)\n\n  return (0,hastscript__WEBPACK_IMPORTED_MODULE_1__.h)(\n    env.tag + '.' + env.classes.join('.'),\n    attributes(env.attributes),\n    env.content\n  )\n}\n\n/**\n * @template {unknown} T\n *   Tokens.\n * @param {T} tokens\n *   Input.\n * @returns {T}\n *   Output, same as input.\n */\nfunction encode(tokens) {\n  return tokens\n}\n\n/**\n * @param {Record<string, string>} record\n *   Attributes.\n * @returns {Record<string, string>}\n *   Attributes.\n */\nfunction attributes(record) {\n  /** @type {string} */\n  let key\n\n  for (key in record) {\n    if (Object.hasOwn(record, key)) {\n      record[key] = (0,parse_entities__WEBPACK_IMPORTED_MODULE_2__.parseEntities)(record[key])\n    }\n  }\n\n  return record\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVmcmFjdG9yL2xpYi9jb3JlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDLFlBQVksb0JBQW9CO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0EsY0FBYyx3Q0FBd0M7QUFDdEQ7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTs7QUFFQTtBQUNBLGFBQWEsNENBQTRDLDJEQUEyRDtBQUNwSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QixjQUFjLFdBQVc7QUFDekIsY0FBYyxzQkFBc0I7QUFDcEMsY0FBYyxrQkFBa0I7QUFDaEMsY0FBYyxtQkFBbUI7QUFDakMsY0FBYyxpQkFBaUI7QUFDL0I7O0FBRUE7QUFDQTtBQUM0QjtBQUNnQjtBQUNQOztBQUVyQztBQUNBOztBQUVBLHNCQUFzQixpREFBSzs7QUFFM0IsV0FBVyxXQUFXO0FBQ3RCO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlEQUFLO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5REFBeUQ7QUFDcEU7QUFDQSxXQUFXLG1EQUFtRDtBQUM5RDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0RBQWdEO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsMENBQTBDO0FBQ3JEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLE1BQU07QUFDbkI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTLDZDQUFDO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiw2REFBYTtBQUNqQztBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbm5zdGFzdGF5Ly4vbm9kZV9tb2R1bGVzL3JlZnJhY3Rvci9saWIvY29yZS5qcz80ZWNlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7RWxlbWVudCwgUm9vdCwgVGV4dH0gZnJvbSAnaGFzdCdcbiAqIEBpbXBvcnQge0dyYW1tYXIsIExhbmd1YWdlc30gZnJvbSAncHJpc21qcydcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIF9Ub2tlblxuICogICBIaWRkZW4gUHJpc20gdG9rZW4uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYWxpYXNcbiAqICAgQWxpYXMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udGVudFxuICogICBDb250ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlbmd0aFxuICogICBMZW5ndGguXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZVxuICogICBUeXBlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgX0VudlxuICogICBIaWRkZW4gUHJpc20gZW52aXJvbm1lbnQuXG4gKiBAcHJvcGVydHkge1JlY29yZDxzdHJpbmcsIHN0cmluZz59IGF0dHJpYnV0ZXNcbiAqICAgQXR0cmlidXRlcy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gY2xhc3Nlc1xuICogICBDbGFzc2VzLlxuICogQHByb3BlcnR5IHtBcnJheTxFbGVtZW50IHwgVGV4dD4gfCBFbGVtZW50IHwgVGV4dH0gY29udGVudFxuICogICBDb250ZW50LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxhbmd1YWdlXG4gKiAgIExhbmd1YWdlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRhZ1xuICogICBUYWcuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZVxuICogICBUeXBlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeygocHJpc206IFJlZnJhY3RvcikgPT4gdW5kZWZpbmVkIHwgdm9pZCkgJiB7YWxpYXNlcz86IEFycmF5PHN0cmluZz4gfCB1bmRlZmluZWQsIGRpc3BsYXlOYW1lOiBzdHJpbmd9fSBTeW50YXhcbiAqICAgUmVmcmFjdG9yIHN5bnRheCBmdW5jdGlvbi5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIFJlZnJhY3RvclxuICogICBWaXJ0dWFsIHN5bnRheCBoaWdobGlnaHRpbmdcbiAqIEBwcm9wZXJ0eSB7dHlwZW9mIGFsaWFzfSBhbGlhc1xuICogQHByb3BlcnR5IHtMYW5ndWFnZXN9IGxhbmd1YWdlc1xuICogQHByb3BlcnR5IHt0eXBlb2YgbGlzdExhbmd1YWdlc30gbGlzdExhbmd1YWdlc1xuICogQHByb3BlcnR5IHt0eXBlb2YgaGlnaGxpZ2h0fSBoaWdobGlnaHRcbiAqIEBwcm9wZXJ0eSB7dHlwZW9mIHJlZ2lzdGVyZWR9IHJlZ2lzdGVyZWRcbiAqIEBwcm9wZXJ0eSB7dHlwZW9mIHJlZ2lzdGVyfSByZWdpc3RlclxuICovXG5cbi8vIExvYWQgYWxsIHN0dWZmIGluIGBwcmlzbS5qc2AgaXRzZWxmLCBleGNlcHQgZm9yIGBwcmlzbS1maWxlLWhpZ2hsaWdodC5qc2AuXG4vLyBUaGUgd3JhcHBlZCBub24tbGVha3kgZ3JhbW1hcnMgYXJlIGxvYWRlZCBpbnN0ZWFkIG9mIFByaXNt4oCZcyBvcmlnaW5hbHMuXG5pbXBvcnQge2h9IGZyb20gJ2hhc3RzY3JpcHQnXG5pbXBvcnQge3BhcnNlRW50aXRpZXN9IGZyb20gJ3BhcnNlLWVudGl0aWVzJ1xuaW1wb3J0IHtQcmlzbX0gZnJvbSAnLi9wcmlzbS1jb3JlLmpzJ1xuXG4vLyBJbmhlcml0LlxuZnVuY3Rpb24gUmVmcmFjdG9yKCkge31cblxuUmVmcmFjdG9yLnByb3RvdHlwZSA9IFByaXNtXG5cbi8qKiBAdHlwZSB7UmVmcmFjdG9yfSAqL1xuLy8gQHRzLWV4cGVjdC1lcnJvcjogVFMgaXMgd3JvbmcuXG5leHBvcnQgY29uc3QgcmVmcmFjdG9yID0gbmV3IFJlZnJhY3RvcigpXG5cbi8vIENyZWF0ZS5cbnJlZnJhY3Rvci5oaWdobGlnaHQgPSBoaWdobGlnaHRcbnJlZnJhY3Rvci5yZWdpc3RlciA9IHJlZ2lzdGVyXG5yZWZyYWN0b3IuYWxpYXMgPSBhbGlhc1xucmVmcmFjdG9yLnJlZ2lzdGVyZWQgPSByZWdpc3RlcmVkXG5yZWZyYWN0b3IubGlzdExhbmd1YWdlcyA9IGxpc3RMYW5ndWFnZXNcblxuLy8gQHRzLWV4cGVjdC1lcnJvciBPdmVyd3JpdGUgUHJpc20uXG5yZWZyYWN0b3IudXRpbC5lbmNvZGUgPSBlbmNvZGVcbi8vIEB0cy1leHBlY3QtZXJyb3IgT3ZlcndyaXRlIFByaXNtLlxucmVmcmFjdG9yLlRva2VuLnN0cmluZ2lmeSA9IHN0cmluZ2lmeVxuXG4vKipcbiAqIEhpZ2hsaWdodCBgdmFsdWVgIChjb2RlKSBhcyBgbGFuZ3VhZ2VgIChwcm9ncmFtbWluZyBsYW5ndWFnZSkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiAgIENvZGUgdG8gaGlnaGxpZ2h0LlxuICogQHBhcmFtIHtHcmFtbWFyIHwgc3RyaW5nfSBsYW5ndWFnZVxuICogICBQcm9ncmFtbWluZyBsYW5ndWFnZSBuYW1lLCBhbGlhcywgb3IgZ3JhbW1hci5cbiAqIEByZXR1cm5zIHtSb290fVxuICogICBOb2RlIHJlcHJlc2VudGluZyBoaWdobGlnaHRlZCBjb2RlLlxuICovXG5mdW5jdGlvbiBoaWdobGlnaHQodmFsdWUsIGxhbmd1YWdlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYHN0cmluZ2AgZm9yIGB2YWx1ZWAsIGdvdCBgJyArIHZhbHVlICsgJ2AnKVxuICB9XG5cbiAgLyoqIEB0eXBlIHtHcmFtbWFyfSAqL1xuICBsZXQgZ3JhbW1hclxuICAvKiogQHR5cGUge3N0cmluZyB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IG5hbWVcblxuICAvLyBgbmFtZWAgaXMgYSBncmFtbWFyIG9iamVjdC5cbiAgLy8gVGhpcyB3YXMgY2FsbGVkIGludGVybmFsbHkgYnkgUHJpc20uanMgYmVmb3JlIDEuMjguMC5cbiAgLyogYzggaWdub3JlIG5leHQgMiAqL1xuICBpZiAobGFuZ3VhZ2UgJiYgdHlwZW9mIGxhbmd1YWdlID09PSAnb2JqZWN0Jykge1xuICAgIGdyYW1tYXIgPSBsYW5ndWFnZVxuICB9IGVsc2Uge1xuICAgIG5hbWUgPSBsYW5ndWFnZVxuXG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYHN0cmluZ2AgZm9yIGBuYW1lYCwgZ290IGAnICsgbmFtZSArICdgJylcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0Lmhhc093bihyZWZyYWN0b3IubGFuZ3VhZ2VzLCBuYW1lKSkge1xuICAgICAgZ3JhbW1hciA9IHJlZnJhY3Rvci5sYW5ndWFnZXNbbmFtZV1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGxhbmd1YWdlOiBgJyArIG5hbWUgKyAnYCBpcyBub3QgcmVnaXN0ZXJlZCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAncm9vdCcsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogd2UgaGFja2VkIFByaXNtIHRvIGFjY2VwdCBhbmQgcmV0dXJuIHRoZSB0aGluZ3Mgd2Ugd2FudC5cbiAgICBjaGlsZHJlbjogUHJpc20uaGlnaGxpZ2h0LmNhbGwocmVmcmFjdG9yLCB2YWx1ZSwgZ3JhbW1hciwgbmFtZSlcbiAgfVxufVxuXG4vKipcbiAqIFJlZ2lzdGVyIGEgc3ludGF4LlxuICpcbiAqIEBwYXJhbSB7U3ludGF4fSBzeW50YXhcbiAqICAgTGFuZ3VhZ2UgZnVuY3Rpb24gbWFkZSBmb3IgcmVmcmFjdG9yLCBhcyBpbiwgdGhlIGZpbGVzIGluXG4gKiAgIGByZWZyYWN0b3IvbGFuZy8qLmpzYC5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyKHN5bnRheCkge1xuICBpZiAodHlwZW9mIHN5bnRheCAhPT0gJ2Z1bmN0aW9uJyB8fCAhc3ludGF4LmRpc3BsYXlOYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBgZnVuY3Rpb25gIGZvciBgc3ludGF4YCwgZ290IGAnICsgc3ludGF4ICsgJ2AnKVxuICB9XG5cbiAgLy8gRG8gbm90IGR1cGxpY2F0ZSByZWdpc3RyYXRpb25zLlxuICBpZiAoIU9iamVjdC5oYXNPd24ocmVmcmFjdG9yLmxhbmd1YWdlcywgc3ludGF4LmRpc3BsYXlOYW1lKSkge1xuICAgIHN5bnRheChyZWZyYWN0b3IpXG4gIH1cbn1cblxuLyoqXG4gKiBSZWdpc3RlciBhbGlhc2VzIGZvciBhbHJlYWR5IHJlZ2lzdGVyZWQgbGFuZ3VhZ2VzLlxuICpcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgUmVhZG9ubHlBcnJheTxzdHJpbmc+IHwgc3RyaW5nPiB8IHN0cmluZ30gbGFuZ3VhZ2VcbiAqICAgTGFuZ3VhZ2UgdG8gYWxpYXMuXG4gKiBAcGFyYW0ge1JlYWRvbmx5QXJyYXk8c3RyaW5nPiB8IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFthbGlhc11cbiAqICAgQWxpYXNlcy5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIGFsaWFzKGxhbmd1YWdlLCBhbGlhcykge1xuICBjb25zdCBsYW5ndWFnZXMgPSByZWZyYWN0b3IubGFuZ3VhZ2VzXG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgUmVhZG9ubHlBcnJheTxzdHJpbmc+IHwgc3RyaW5nPn0gKi9cbiAgbGV0IG1hcCA9IHt9XG5cbiAgaWYgKHR5cGVvZiBsYW5ndWFnZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoYWxpYXMpIHtcbiAgICAgIG1hcFtsYW5ndWFnZV0gPSBhbGlhc1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXAgPSBsYW5ndWFnZVxuICB9XG5cbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gIGxldCBrZXlcblxuICBmb3IgKGtleSBpbiBtYXApIHtcbiAgICBpZiAoT2JqZWN0Lmhhc093bihtYXAsIGtleSkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gbWFwW2tleV1cbiAgICAgIGNvbnN0IGxpc3QgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gW3ZhbHVlXSA6IHZhbHVlXG4gICAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgICAgIGxhbmd1YWdlc1tsaXN0W2luZGV4XV0gPSBsYW5ndWFnZXNba2V5XVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYW4gYGFsaWFzYCBvciBgbGFuZ3VhZ2VgIGlzIHJlZ2lzdGVyZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFsaWFzT3JMYW5ndWFnZVxuICogICBMYW5ndWFnZSBvciBhbGlhcyB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogICBXaGV0aGVyIHRoZSBsYW5ndWFnZSBpcyByZWdpc3RlcmVkLlxuICovXG5mdW5jdGlvbiByZWdpc3RlcmVkKGFsaWFzT3JMYW5ndWFnZSkge1xuICBpZiAodHlwZW9mIGFsaWFzT3JMYW5ndWFnZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ0V4cGVjdGVkIGBzdHJpbmdgIGZvciBgYWxpYXNPckxhbmd1YWdlYCwgZ290IGAnICsgYWxpYXNPckxhbmd1YWdlICsgJ2AnXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5oYXNPd24ocmVmcmFjdG9yLmxhbmd1YWdlcywgYWxpYXNPckxhbmd1YWdlKVxufVxuXG4vKipcbiAqIExpc3QgYWxsIHJlZ2lzdGVyZWQgbGFuZ3VhZ2VzIChuYW1lcyBhbmQgYWxpYXNlcykuXG4gKlxuICogQHJldHVybnMge0FycmF5PHN0cmluZz59XG4gKiAgIExpc3Qgb2YgbGFuZ3VhZ2UgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGxpc3RMYW5ndWFnZXMoKSB7XG4gIGNvbnN0IGxhbmd1YWdlcyA9IHJlZnJhY3Rvci5sYW5ndWFnZXNcbiAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICBjb25zdCBsaXN0ID0gW11cbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gIGxldCBsYW5ndWFnZVxuXG4gIGZvciAobGFuZ3VhZ2UgaW4gbGFuZ3VhZ2VzKSB7XG4gICAgaWYgKFxuICAgICAgT2JqZWN0Lmhhc093bihsYW5ndWFnZXMsIGxhbmd1YWdlKSAmJlxuICAgICAgdHlwZW9mIGxhbmd1YWdlc1tsYW5ndWFnZV0gPT09ICdvYmplY3QnXG4gICAgKSB7XG4gICAgICBsaXN0LnB1c2gobGFuZ3VhZ2UpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxpc3Rcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PF9Ub2tlbiB8IHN0cmluZz4gfCBfVG9rZW4gfCBzdHJpbmd9IHZhbHVlXG4gKiAgIFRva2VuIHRvIHN0cmluZ2lmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZVxuICogICBMYW5ndWFnZSBvZiB0aGUgdG9rZW4uXG4gKiBAcmV0dXJucyB7QXJyYXk8RWxlbWVudCB8IFRleHQ+IHwgRWxlbWVudCB8IFRleHR9XG4gKiAgIE5vZGUgcmVwcmVzZW50aW5nIHRoZSB0b2tlbi5cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlLCBsYW5ndWFnZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7dHlwZTogJ3RleHQnLCB2YWx1ZX1cbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8RWxlbWVudCB8IFRleHQ+fSAqL1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdXG4gICAgbGV0IGluZGV4ID0gLTFcblxuICAgIHdoaWxlICgrK2luZGV4IDwgdmFsdWUubGVuZ3RoKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlW2luZGV4XSAhPT0gbnVsbCAmJlxuICAgICAgICB2YWx1ZVtpbmRleF0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB2YWx1ZVtpbmRleF0gIT09ICcnXG4gICAgICApIHtcbiAgICAgICAgLy8gQ2FzdCBiZWNhdXNlIHdlIGFzc3VtZSBubyBzdWItYXJyYXlzLlxuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAvKiogQHR5cGUge0VsZW1lbnQgfCBUZXh0fSAqLyAoc3RyaW5naWZ5KHZhbHVlW2luZGV4XSwgbGFuZ3VhZ2UpKVxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLyoqIEB0eXBlIHtfRW52fSAqL1xuICBjb25zdCBlbnYgPSB7XG4gICAgYXR0cmlidXRlczoge30sXG4gICAgY2xhc3NlczogWyd0b2tlbicsIHZhbHVlLnR5cGVdLFxuICAgIGNvbnRlbnQ6IHN0cmluZ2lmeSh2YWx1ZS5jb250ZW50LCBsYW5ndWFnZSksXG4gICAgbGFuZ3VhZ2UsXG4gICAgdGFnOiAnc3BhbicsXG4gICAgdHlwZTogdmFsdWUudHlwZVxuICB9XG5cbiAgaWYgKHZhbHVlLmFsaWFzKSB7XG4gICAgZW52LmNsYXNzZXMucHVzaChcbiAgICAgIC4uLih0eXBlb2YgdmFsdWUuYWxpYXMgPT09ICdzdHJpbmcnID8gW3ZhbHVlLmFsaWFzXSA6IHZhbHVlLmFsaWFzKVxuICAgIClcbiAgfVxuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgUHJpc20uXG4gIHJlZnJhY3Rvci5ob29rcy5ydW4oJ3dyYXAnLCBlbnYpXG5cbiAgcmV0dXJuIGgoXG4gICAgZW52LnRhZyArICcuJyArIGVudi5jbGFzc2VzLmpvaW4oJy4nKSxcbiAgICBhdHRyaWJ1dGVzKGVudi5hdHRyaWJ1dGVzKSxcbiAgICBlbnYuY29udGVudFxuICApXG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHt1bmtub3dufSBUXG4gKiAgIFRva2Vucy5cbiAqIEBwYXJhbSB7VH0gdG9rZW5zXG4gKiAgIElucHV0LlxuICogQHJldHVybnMge1R9XG4gKiAgIE91dHB1dCwgc2FtZSBhcyBpbnB1dC5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlKHRva2Vucykge1xuICByZXR1cm4gdG9rZW5zXG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSByZWNvcmRcbiAqICAgQXR0cmlidXRlcy5cbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICogICBBdHRyaWJ1dGVzLlxuICovXG5mdW5jdGlvbiBhdHRyaWJ1dGVzKHJlY29yZCkge1xuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgbGV0IGtleVxuXG4gIGZvciAoa2V5IGluIHJlY29yZCkge1xuICAgIGlmIChPYmplY3QuaGFzT3duKHJlY29yZCwga2V5KSkge1xuICAgICAgcmVjb3JkW2tleV0gPSBwYXJzZUVudGl0aWVzKHJlY29yZFtrZXldKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWNvcmRcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/refractor/lib/core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/refractor/lib/prism-core.js":
/*!**************************************************!*\
  !*** ./node_modules/refractor/lib/prism-core.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Prism: () => (/* binding */ Prism)\n/* harmony export */ });\n// @ts-nocheck\n\n// This is a slimmed down version of `prism-core.js`, to remove globals,\n// document, workers, `util.encode`, `Token.stringify`\n\n// Private helper vars\nvar lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i\nvar uniqueId = 0\n\n// The grammar object for plaintext\nvar plainTextGrammar = {}\n\nvar _ = {\n  /**\n   * A namespace for utility methods.\n   *\n   * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n   * change or disappear at any time.\n   *\n   * @namespace\n   * @memberof Prism\n   */\n  util: {\n    /**\n     * Returns the name of the type of the given value.\n     *\n     * @param {any} o\n     * @returns {string}\n     * @example\n     * type(null)      === 'Null'\n     * type(undefined) === 'Undefined'\n     * type(123)       === 'Number'\n     * type('foo')     === 'String'\n     * type(true)      === 'Boolean'\n     * type([1, 2])    === 'Array'\n     * type({})        === 'Object'\n     * type(String)    === 'Function'\n     * type(/abc+/)    === 'RegExp'\n     */\n    type: function (o) {\n      return Object.prototype.toString.call(o).slice(8, -1)\n    },\n\n    /**\n     * Returns a unique number for the given object. Later calls will still return the same number.\n     *\n     * @param {Object} obj\n     * @returns {number}\n     */\n    objId: function (obj) {\n      if (!obj['__id']) {\n        Object.defineProperty(obj, '__id', {value: ++uniqueId})\n      }\n      return obj['__id']\n    },\n\n    /**\n     * Creates a deep clone of the given object.\n     *\n     * The main intended use of this function is to clone language definitions.\n     *\n     * @param {T} o\n     * @param {Record<number, any>} [visited]\n     * @returns {T}\n     * @template T\n     */\n    clone: function deepClone(o, visited) {\n      visited = visited || {}\n\n      var clone\n      var id\n      switch (_.util.type(o)) {\n        case 'Object':\n          id = _.util.objId(o)\n          if (visited[id]) {\n            return visited[id]\n          }\n          clone = /** @type {Record<string, any>} */ ({})\n          visited[id] = clone\n\n          for (var key in o) {\n            if (o.hasOwnProperty(key)) {\n              clone[key] = deepClone(o[key], visited)\n            }\n          }\n\n          return /** @type {any} */ (clone)\n\n        case 'Array':\n          id = _.util.objId(o)\n          if (visited[id]) {\n            return visited[id]\n          }\n          clone = []\n          visited[id] = clone\n\n          ;/** @type {Array} */ (/** @type {any} */ (o)).forEach(\n            function (v, i) {\n              clone[i] = deepClone(v, visited)\n            }\n          )\n\n          return /** @type {any} */ (clone)\n\n        default:\n          return o\n      }\n    }\n  },\n\n  /**\n   * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n   *\n   * @namespace\n   * @memberof Prism\n   * @public\n   */\n  languages: {\n    /**\n     * The grammar for plain, unformatted text.\n     */\n    plain: plainTextGrammar,\n    plaintext: plainTextGrammar,\n    text: plainTextGrammar,\n    txt: plainTextGrammar,\n\n    /**\n     * Creates a deep copy of the language with the given id and appends the given tokens.\n     *\n     * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n     * will be overwritten at its original position.\n     *\n     * ## Best practices\n     *\n     * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n     * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n     * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n     *\n     * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n     * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n     *\n     * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n     * @param {Grammar} redef The new tokens to append.\n     * @returns {Grammar} The new language created.\n     * @public\n     * @example\n     * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n     *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n     *     // at its original position\n     *     'comment': { ... },\n     *     // CSS doesn't have a 'color' token, so this token will be appended\n     *     'color': /\\b(?:red|green|blue)\\b/\n     * });\n     */\n    extend: function (id, redef) {\n      var lang = _.util.clone(_.languages[id])\n\n      for (var key in redef) {\n        lang[key] = redef[key]\n      }\n\n      return lang\n    },\n\n    /**\n     * Inserts tokens _before_ another token in a language definition or any other grammar.\n     *\n     * ## Usage\n     *\n     * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n     * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n     * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n     * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n     * this:\n     *\n     * ```js\n     * Prism.languages.markup.style = {\n     *     // token\n     * };\n     * ```\n     *\n     * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n     * before existing tokens. For the CSS example above, you would use it like this:\n     *\n     * ```js\n     * Prism.languages.insertBefore('markup', 'cdata', {\n     *     'style': {\n     *         // token\n     *     }\n     * });\n     * ```\n     *\n     * ## Special cases\n     *\n     * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n     * will be ignored.\n     *\n     * This behavior can be used to insert tokens after `before`:\n     *\n     * ```js\n     * Prism.languages.insertBefore('markup', 'comment', {\n     *     'comment': Prism.languages.markup.comment,\n     *     // tokens after 'comment'\n     * });\n     * ```\n     *\n     * ## Limitations\n     *\n     * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n     * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n     * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n     * deleting properties which is necessary to insert at arbitrary positions.\n     *\n     * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n     * Instead, it will create a new object and replace all references to the target object with the new one. This\n     * can be done without temporarily deleting properties, so the iteration order is well-defined.\n     *\n     * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n     * you hold the target object in a variable, then the value of the variable will not change.\n     *\n     * ```js\n     * var oldMarkup = Prism.languages.markup;\n     * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n     *\n     * assert(oldMarkup !== Prism.languages.markup);\n     * assert(newMarkup === Prism.languages.markup);\n     * ```\n     *\n     * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n     * object to be modified.\n     * @param {string} before The key to insert before.\n     * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n     * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n     * object to be modified.\n     *\n     * Defaults to `Prism.languages`.\n     * @returns {Grammar} The new grammar object.\n     * @public\n     */\n    insertBefore: function (inside, before, insert, root) {\n      root = root || /** @type {any} */ (_.languages)\n      var grammar = root[inside]\n      /** @type {Grammar} */\n      var ret = {}\n\n      for (var token in grammar) {\n        if (grammar.hasOwnProperty(token)) {\n          if (token == before) {\n            for (var newToken in insert) {\n              if (insert.hasOwnProperty(newToken)) {\n                ret[newToken] = insert[newToken]\n              }\n            }\n          }\n\n          // Do not insert token which also occur in insert. See #1525\n          if (!insert.hasOwnProperty(token)) {\n            ret[token] = grammar[token]\n          }\n        }\n      }\n\n      var old = root[inside]\n      root[inside] = ret\n\n      // Update references in other language definitions\n      _.languages.DFS(_.languages, function (key, value) {\n        if (value === old && key != inside) {\n          this[key] = ret\n        }\n      })\n\n      return ret\n    },\n\n    // Traverse a language definition with Depth First Search\n    DFS: function DFS(o, callback, type, visited) {\n      visited = visited || {}\n\n      var objId = _.util.objId\n\n      for (var i in o) {\n        if (o.hasOwnProperty(i)) {\n          callback.call(o, i, o[i], type || i)\n\n          var property = o[i]\n          var propertyType = _.util.type(property)\n\n          if (propertyType === 'Object' && !visited[objId(property)]) {\n            visited[objId(property)] = true\n            DFS(property, callback, null, visited)\n          } else if (propertyType === 'Array' && !visited[objId(property)]) {\n            visited[objId(property)] = true\n            DFS(property, callback, i, visited)\n          }\n        }\n      }\n    }\n  },\n\n  plugins: {},\n\n  /**\n   * Low-level function, only use if you know what youâ€™re doing. It accepts a string of text as input\n   * and the language definitions to use, and returns a string with the HTML produced.\n   *\n   * The following hooks will be run:\n   * 1. `before-tokenize`\n   * 2. `after-tokenize`\n   * 3. `wrap`: On each {@link Token}.\n   *\n   * @param {string} text A string with the code to be highlighted.\n   * @param {Grammar} grammar An object containing the tokens to use.\n   *\n   * Usually a language definition like `Prism.languages.markup`.\n   * @param {string} language The name of the language definition passed to `grammar`.\n   * @returns {string} The highlighted HTML.\n   * @memberof Prism\n   * @public\n   * @example\n   * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n   */\n  highlight: function (text, grammar, language) {\n    var env = {\n      code: text,\n      grammar: grammar,\n      language: language\n    }\n    _.hooks.run('before-tokenize', env)\n    if (!env.grammar) {\n      throw new Error('The language \"' + env.language + '\" has no grammar.')\n    }\n    env.tokens = _.tokenize(env.code, env.grammar)\n    _.hooks.run('after-tokenize', env)\n    return Token.stringify(_.util.encode(env.tokens), env.language)\n  },\n\n  /**\n   * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n   * and the language definitions to use, and returns an array with the tokenized code.\n   *\n   * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n   *\n   * This method could be useful in other contexts as well, as a very crude parser.\n   *\n   * @param {string} text A string with the code to be highlighted.\n   * @param {Grammar} grammar An object containing the tokens to use.\n   *\n   * Usually a language definition like `Prism.languages.markup`.\n   * @returns {TokenStream} An array of strings and tokens, a token stream.\n   * @memberof Prism\n   * @public\n   * @example\n   * let code = `var foo = 0;`;\n   * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n   * tokens.forEach(token => {\n   *     if (token instanceof Prism.Token && token.type === 'number') {\n   *         console.log(`Found numeric literal: ${token.content}`);\n   *     }\n   * });\n   */\n  tokenize: function (text, grammar) {\n    var rest = grammar.rest\n    if (rest) {\n      for (var token in rest) {\n        grammar[token] = rest[token]\n      }\n\n      delete grammar.rest\n    }\n\n    var tokenList = new LinkedList()\n    addAfter(tokenList, tokenList.head, text)\n\n    matchGrammar(text, tokenList, grammar, tokenList.head, 0)\n\n    return toArray(tokenList)\n  },\n\n  /**\n   * @namespace\n   * @memberof Prism\n   * @public\n   */\n  hooks: {\n    all: {},\n\n    /**\n     * Adds the given callback to the list of callbacks for the given hook.\n     *\n     * The callback will be invoked when the hook it is registered for is run.\n     * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n     *\n     * One callback function can be registered to multiple hooks and the same hook multiple times.\n     *\n     * @param {string} name The name of the hook.\n     * @param {HookCallback} callback The callback function which is given environment variables.\n     * @public\n     */\n    add: function (name, callback) {\n      var hooks = _.hooks.all\n\n      hooks[name] = hooks[name] || []\n\n      hooks[name].push(callback)\n    },\n\n    /**\n     * Runs a hook invoking all registered callbacks with the given environment variables.\n     *\n     * Callbacks will be invoked synchronously and in the order in which they were registered.\n     *\n     * @param {string} name The name of the hook.\n     * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n     * @public\n     */\n    run: function (name, env) {\n      var callbacks = _.hooks.all[name]\n\n      if (!callbacks || !callbacks.length) {\n        return\n      }\n\n      for (var i = 0, callback; (callback = callbacks[i++]); ) {\n        callback(env)\n      }\n    }\n  },\n\n  Token: Token\n}\n\n// Typescript note:\n// The following can be used to import the Token type in JSDoc:\n//\n//   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\n/**\n * Creates a new token.\n *\n * @param {string} type See {@link Token#type type}\n * @param {string | TokenStream} content See {@link Token#content content}\n * @param {string|string[]} [alias] The alias(es) of the token.\n * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n * @class\n * @global\n * @public\n */\nfunction Token(type, content, alias, matchedStr) {\n  /**\n   * The type of the token.\n   *\n   * This is usually the key of a pattern in a {@link Grammar}.\n   *\n   * @type {string}\n   * @see GrammarToken\n   * @public\n   */\n  this.type = type\n  /**\n   * The strings or tokens contained by this token.\n   *\n   * This will be a token stream if the pattern matched also defined an `inside` grammar.\n   *\n   * @type {string | TokenStream}\n   * @public\n   */\n  this.content = content\n  /**\n   * The alias(es) of the token.\n   *\n   * @type {string|string[]}\n   * @see GrammarToken\n   * @public\n   */\n  this.alias = alias\n  // Copy of the full string this token was created from\n  this.length = (matchedStr || '').length | 0\n}\n\n/**\n * A token stream is an array of strings and {@link Token Token} objects.\n *\n * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n * them.\n *\n * 1. No adjacent strings.\n * 2. No empty strings.\n *\n *    The only exception here is the token stream that only contains the empty string and nothing else.\n *\n * @typedef {Array<string | Token>} TokenStream\n * @global\n * @public\n */\n\n/**\n * @param {RegExp} pattern\n * @param {number} pos\n * @param {string} text\n * @param {boolean} lookbehind\n * @returns {RegExpExecArray | null}\n */\nfunction matchPattern(pattern, pos, text, lookbehind) {\n  pattern.lastIndex = pos\n  var match = pattern.exec(text)\n  if (match && lookbehind && match[1]) {\n    // change the match to remove the text matched by the Prism lookbehind group\n    var lookbehindLength = match[1].length\n    match.index += lookbehindLength\n    match[0] = match[0].slice(lookbehindLength)\n  }\n  return match\n}\n\n/**\n * @param {string} text\n * @param {LinkedList<string | Token>} tokenList\n * @param {any} grammar\n * @param {LinkedListNode<string | Token>} startNode\n * @param {number} startPos\n * @param {RematchOptions} [rematch]\n * @returns {void}\n * @private\n *\n * @typedef RematchOptions\n * @property {string} cause\n * @property {number} reach\n */\nfunction matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n  for (var token in grammar) {\n    if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n      continue\n    }\n\n    var patterns = grammar[token]\n    patterns = Array.isArray(patterns) ? patterns : [patterns]\n\n    for (var j = 0; j < patterns.length; ++j) {\n      if (rematch && rematch.cause == token + ',' + j) {\n        return\n      }\n\n      var patternObj = patterns[j]\n      var inside = patternObj.inside\n      var lookbehind = !!patternObj.lookbehind\n      var greedy = !!patternObj.greedy\n      var alias = patternObj.alias\n\n      if (greedy && !patternObj.pattern.global) {\n        // Without the global flag, lastIndex won't work\n        var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0]\n        patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g')\n      }\n\n      /** @type {RegExp} */\n      var pattern = patternObj.pattern || patternObj\n\n      for (\n        // iterate the token list and keep track of the current token/string position\n        var currentNode = startNode.next, pos = startPos;\n        currentNode !== tokenList.tail;\n        pos += currentNode.value.length, currentNode = currentNode.next\n      ) {\n        if (rematch && pos >= rematch.reach) {\n          break\n        }\n\n        var str = currentNode.value\n\n        if (tokenList.length > text.length) {\n          // Something went terribly wrong, ABORT, ABORT!\n          return\n        }\n\n        if (str instanceof Token) {\n          continue\n        }\n\n        var removeCount = 1 // this is the to parameter of removeBetween\n        var match\n\n        if (greedy) {\n          match = matchPattern(pattern, pos, text, lookbehind)\n          if (!match || match.index >= text.length) {\n            break\n          }\n\n          var from = match.index\n          var to = match.index + match[0].length\n          var p = pos\n\n          // find the node that contains the match\n          p += currentNode.value.length\n          while (from >= p) {\n            currentNode = currentNode.next\n            p += currentNode.value.length\n          }\n          // adjust pos (and p)\n          p -= currentNode.value.length\n          pos = p\n\n          // the current node is a Token, then the match starts inside another Token, which is invalid\n          if (currentNode.value instanceof Token) {\n            continue\n          }\n\n          // find the last node which is affected by this match\n          for (\n            var k = currentNode;\n            k !== tokenList.tail && (p < to || typeof k.value === 'string');\n            k = k.next\n          ) {\n            removeCount++\n            p += k.value.length\n          }\n          removeCount--\n\n          // replace with the new match\n          str = text.slice(pos, p)\n          match.index -= pos\n        } else {\n          match = matchPattern(pattern, 0, str, lookbehind)\n          if (!match) {\n            continue\n          }\n        }\n\n        // eslint-disable-next-line no-redeclare\n        var from = match.index\n        var matchStr = match[0]\n        var before = str.slice(0, from)\n        var after = str.slice(from + matchStr.length)\n\n        var reach = pos + str.length\n        if (rematch && reach > rematch.reach) {\n          rematch.reach = reach\n        }\n\n        var removeFrom = currentNode.prev\n\n        if (before) {\n          removeFrom = addAfter(tokenList, removeFrom, before)\n          pos += before.length\n        }\n\n        removeRange(tokenList, removeFrom, removeCount)\n\n        var wrapped = new Token(\n          token,\n          inside ? _.tokenize(matchStr, inside) : matchStr,\n          alias,\n          matchStr\n        )\n        currentNode = addAfter(tokenList, removeFrom, wrapped)\n\n        if (after) {\n          addAfter(tokenList, currentNode, after)\n        }\n\n        if (removeCount > 1) {\n          // at least one Token object was removed, so we have to do some rematching\n          // this can only happen if the current pattern is greedy\n\n          /** @type {RematchOptions} */\n          var nestedRematch = {\n            cause: token + ',' + j,\n            reach: reach\n          }\n          matchGrammar(\n            text,\n            tokenList,\n            grammar,\n            currentNode.prev,\n            pos,\n            nestedRematch\n          )\n\n          // the reach might have been extended because of the rematching\n          if (rematch && nestedRematch.reach > rematch.reach) {\n            rematch.reach = nestedRematch.reach\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * @typedef LinkedListNode\n * @property {T} value\n * @property {LinkedListNode<T> | null} prev The previous node.\n * @property {LinkedListNode<T> | null} next The next node.\n * @template T\n * @private\n */\n\n/**\n * @template T\n * @private\n */\nfunction LinkedList() {\n  /** @type {LinkedListNode<T>} */\n  var head = {value: null, prev: null, next: null}\n  /** @type {LinkedListNode<T>} */\n  var tail = {value: null, prev: head, next: null}\n  head.next = tail\n\n  /** @type {LinkedListNode<T>} */\n  this.head = head\n  /** @type {LinkedListNode<T>} */\n  this.tail = tail\n  this.length = 0\n}\n\n/**\n * Adds a new node with the given value to the list.\n *\n * @param {LinkedList<T>} list\n * @param {LinkedListNode<T>} node\n * @param {T} value\n * @returns {LinkedListNode<T>} The added node.\n * @template T\n */\nfunction addAfter(list, node, value) {\n  // assumes that node != list.tail && values.length >= 0\n  var next = node.next\n\n  var newNode = {value: value, prev: node, next: next}\n  node.next = newNode\n  next.prev = newNode\n  list.length++\n\n  return newNode\n}\n/**\n * Removes `count` nodes after the given node. The given node will not be removed.\n *\n * @param {LinkedList<T>} list\n * @param {LinkedListNode<T>} node\n * @param {number} count\n * @template T\n */\nfunction removeRange(list, node, count) {\n  var next = node.next\n  for (var i = 0; i < count && next !== list.tail; i++) {\n    next = next.next\n  }\n  node.next = next\n  next.prev = node\n  list.length -= i\n}\n/**\n * @param {LinkedList<T>} list\n * @returns {T[]}\n * @template T\n */\nfunction toArray(list) {\n  var array = []\n  var node = list.head.next\n  while (node !== list.tail) {\n    array.push(node.value)\n    node = node.next\n  }\n  return array\n}\n\nconst Prism = _\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVmcmFjdG9yL2xpYi9wcmlzbS1jb3JlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGtCQUFrQjtBQUM5RDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUscUJBQXFCO0FBQ3BDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFCQUFxQixNQUFNO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLEtBQUs7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsV0FBVyxPQUFPLGVBQWUsS0FBSztBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsS0FBSzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlDQUFpQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyIsInNvdXJjZXMiOlsid2VicGFjazovL2lubnN0YXN0YXkvLi9ub2RlX21vZHVsZXMvcmVmcmFjdG9yL2xpYi9wcmlzbS1jb3JlLmpzPzY3YTciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQHRzLW5vY2hlY2tcblxuLy8gVGhpcyBpcyBhIHNsaW1tZWQgZG93biB2ZXJzaW9uIG9mIGBwcmlzbS1jb3JlLmpzYCwgdG8gcmVtb3ZlIGdsb2JhbHMsXG4vLyBkb2N1bWVudCwgd29ya2VycywgYHV0aWwuZW5jb2RlYCwgYFRva2VuLnN0cmluZ2lmeWBcblxuLy8gUHJpdmF0ZSBoZWxwZXIgdmFyc1xudmFyIGxhbmcgPSAvKD86XnxcXHMpbGFuZyg/OnVhZ2UpPy0oW1xcdy1dKykoPz1cXHN8JCkvaVxudmFyIHVuaXF1ZUlkID0gMFxuXG4vLyBUaGUgZ3JhbW1hciBvYmplY3QgZm9yIHBsYWludGV4dFxudmFyIHBsYWluVGV4dEdyYW1tYXIgPSB7fVxuXG52YXIgXyA9IHtcbiAgLyoqXG4gICAqIEEgbmFtZXNwYWNlIGZvciB1dGlsaXR5IG1ldGhvZHMuXG4gICAqXG4gICAqIEFsbCBmdW5jdGlvbiBpbiB0aGlzIG5hbWVzcGFjZSB0aGF0IGFyZSBub3QgZXhwbGljaXRseSBtYXJrZWQgYXMgX3B1YmxpY18gYXJlIGZvciBfX2ludGVybmFsIHVzZSBvbmx5X18gYW5kIG1heVxuICAgKiBjaGFuZ2Ugb3IgZGlzYXBwZWFyIGF0IGFueSB0aW1lLlxuICAgKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBtZW1iZXJvZiBQcmlzbVxuICAgKi9cbiAgdXRpbDoge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHR5cGUgb2YgdGhlIGdpdmVuIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IG9cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdHlwZShudWxsKSAgICAgID09PSAnTnVsbCdcbiAgICAgKiB0eXBlKHVuZGVmaW5lZCkgPT09ICdVbmRlZmluZWQnXG4gICAgICogdHlwZSgxMjMpICAgICAgID09PSAnTnVtYmVyJ1xuICAgICAqIHR5cGUoJ2ZvbycpICAgICA9PT0gJ1N0cmluZydcbiAgICAgKiB0eXBlKHRydWUpICAgICAgPT09ICdCb29sZWFuJ1xuICAgICAqIHR5cGUoWzEsIDJdKSAgICA9PT0gJ0FycmF5J1xuICAgICAqIHR5cGUoe30pICAgICAgICA9PT0gJ09iamVjdCdcbiAgICAgKiB0eXBlKFN0cmluZykgICAgPT09ICdGdW5jdGlvbidcbiAgICAgKiB0eXBlKC9hYmMrLykgICAgPT09ICdSZWdFeHAnXG4gICAgICovXG4gICAgdHlwZTogZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB1bmlxdWUgbnVtYmVyIGZvciB0aGUgZ2l2ZW4gb2JqZWN0LiBMYXRlciBjYWxscyB3aWxsIHN0aWxsIHJldHVybiB0aGUgc2FtZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBvYmpJZDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgaWYgKCFvYmpbJ19faWQnXSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCAnX19pZCcsIHt2YWx1ZTogKyt1bmlxdWVJZH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqWydfX2lkJ11cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlZXAgY2xvbmUgb2YgdGhlIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFRoZSBtYWluIGludGVuZGVkIHVzZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRvIGNsb25lIGxhbmd1YWdlIGRlZmluaXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtUfSBvXG4gICAgICogQHBhcmFtIHtSZWNvcmQ8bnVtYmVyLCBhbnk+fSBbdmlzaXRlZF1cbiAgICAgKiBAcmV0dXJucyB7VH1cbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbiBkZWVwQ2xvbmUobywgdmlzaXRlZCkge1xuICAgICAgdmlzaXRlZCA9IHZpc2l0ZWQgfHwge31cblxuICAgICAgdmFyIGNsb25lXG4gICAgICB2YXIgaWRcbiAgICAgIHN3aXRjaCAoXy51dGlsLnR5cGUobykpIHtcbiAgICAgICAgY2FzZSAnT2JqZWN0JzpcbiAgICAgICAgICBpZCA9IF8udXRpbC5vYmpJZChvKVxuICAgICAgICAgIGlmICh2aXNpdGVkW2lkXSkge1xuICAgICAgICAgICAgcmV0dXJuIHZpc2l0ZWRbaWRdXG4gICAgICAgICAgfVxuICAgICAgICAgIGNsb25lID0gLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAqLyAoe30pXG4gICAgICAgICAgdmlzaXRlZFtpZF0gPSBjbG9uZVxuXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIG8pIHtcbiAgICAgICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgY2xvbmVba2V5XSA9IGRlZXBDbG9uZShvW2tleV0sIHZpc2l0ZWQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAoY2xvbmUpXG5cbiAgICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICAgIGlkID0gXy51dGlsLm9iaklkKG8pXG4gICAgICAgICAgaWYgKHZpc2l0ZWRbaWRdKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRlZFtpZF1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2xvbmUgPSBbXVxuICAgICAgICAgIHZpc2l0ZWRbaWRdID0gY2xvbmVcblxuICAgICAgICAgIDsvKiogQHR5cGUge0FycmF5fSAqLyAoLyoqIEB0eXBlIHthbnl9ICovIChvKSkuZm9yRWFjaChcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgICAgIGNsb25lW2ldID0gZGVlcENsb25lKHYsIHZpc2l0ZWQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuXG4gICAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAoY2xvbmUpXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gb1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBuYW1lc3BhY2UgY29udGFpbnMgYWxsIGN1cnJlbnRseSBsb2FkZWQgbGFuZ3VhZ2VzIGFuZCB0aGUgc29tZSBoZWxwZXIgZnVuY3Rpb25zIHRvIGNyZWF0ZSBhbmQgbW9kaWZ5IGxhbmd1YWdlcy5cbiAgICpcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAbWVtYmVyb2YgUHJpc21cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgbGFuZ3VhZ2VzOiB7XG4gICAgLyoqXG4gICAgICogVGhlIGdyYW1tYXIgZm9yIHBsYWluLCB1bmZvcm1hdHRlZCB0ZXh0LlxuICAgICAqL1xuICAgIHBsYWluOiBwbGFpblRleHRHcmFtbWFyLFxuICAgIHBsYWludGV4dDogcGxhaW5UZXh0R3JhbW1hcixcbiAgICB0ZXh0OiBwbGFpblRleHRHcmFtbWFyLFxuICAgIHR4dDogcGxhaW5UZXh0R3JhbW1hcixcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWVwIGNvcHkgb2YgdGhlIGxhbmd1YWdlIHdpdGggdGhlIGdpdmVuIGlkIGFuZCBhcHBlbmRzIHRoZSBnaXZlbiB0b2tlbnMuXG4gICAgICpcbiAgICAgKiBJZiBhIHRva2VuIGluIGByZWRlZmAgYWxzbyBhcHBlYXJzIGluIHRoZSBjb3BpZWQgbGFuZ3VhZ2UsIHRoZW4gdGhlIGV4aXN0aW5nIHRva2VuIGluIHRoZSBjb3BpZWQgbGFuZ3VhZ2VcbiAgICAgKiB3aWxsIGJlIG92ZXJ3cml0dGVuIGF0IGl0cyBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqICMjIEJlc3QgcHJhY3RpY2VzXG4gICAgICpcbiAgICAgKiBTaW5jZSB0aGUgcG9zaXRpb24gb2Ygb3ZlcndyaXRpbmcgdG9rZW5zICh0b2tlbiBpbiBgcmVkZWZgIHRoYXQgb3ZlcndyaXRlIHRva2VucyBpbiB0aGUgY29waWVkIGxhbmd1YWdlKVxuICAgICAqIGRvZXNuJ3QgbWF0dGVyLCB0aGV5IGNhbiB0ZWNobmljYWxseSBiZSBpbiBhbnkgb3JkZXIuIEhvd2V2ZXIsIHRoaXMgY2FuIGJlIGNvbmZ1c2luZyB0byBvdGhlcnMgdGhhdCB0cnlpbmcgdG9cbiAgICAgKiB1bmRlcnN0YW5kIHRoZSBsYW5ndWFnZSBkZWZpbml0aW9uIGJlY2F1c2UsIG5vcm1hbGx5LCB0aGUgb3JkZXIgb2YgdG9rZW5zIG1hdHRlcnMgaW4gUHJpc20gZ3JhbW1hcnMuXG4gICAgICpcbiAgICAgKiBUaGVyZWZvcmUsIGl0IGlzIGVuY291cmFnZWQgdG8gb3JkZXIgb3ZlcndyaXRpbmcgdG9rZW5zIGFjY29yZGluZyB0byB0aGUgcG9zaXRpb25zIG9mIHRoZSBvdmVyd3JpdHRlbiB0b2tlbnMuXG4gICAgICogRnVydGhlcm1vcmUsIGFsbCBub24tb3ZlcndyaXRpbmcgdG9rZW5zIHNob3VsZCBiZSBwbGFjZWQgYWZ0ZXIgdGhlIG92ZXJ3cml0aW5nIG9uZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBsYW5ndWFnZSB0byBleHRlbmQuIFRoaXMgaGFzIHRvIGJlIGEga2V5IGluIGBQcmlzbS5sYW5ndWFnZXNgLlxuICAgICAqIEBwYXJhbSB7R3JhbW1hcn0gcmVkZWYgVGhlIG5ldyB0b2tlbnMgdG8gYXBwZW5kLlxuICAgICAqIEByZXR1cm5zIHtHcmFtbWFyfSBUaGUgbmV3IGxhbmd1YWdlIGNyZWF0ZWQuXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBleGFtcGxlXG4gICAgICogUHJpc20ubGFuZ3VhZ2VzWydjc3Mtd2l0aC1jb2xvcnMnXSA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NzcycsIHtcbiAgICAgKiAgICAgLy8gUHJpc20ubGFuZ3VhZ2VzLmNzcyBhbHJlYWR5IGhhcyBhICdjb21tZW50JyB0b2tlbiwgc28gdGhpcyB0b2tlbiB3aWxsIG92ZXJ3cml0ZSBDU1MnICdjb21tZW50JyB0b2tlblxuICAgICAqICAgICAvLyBhdCBpdHMgb3JpZ2luYWwgcG9zaXRpb25cbiAgICAgKiAgICAgJ2NvbW1lbnQnOiB7IC4uLiB9LFxuICAgICAqICAgICAvLyBDU1MgZG9lc24ndCBoYXZlIGEgJ2NvbG9yJyB0b2tlbiwgc28gdGhpcyB0b2tlbiB3aWxsIGJlIGFwcGVuZGVkXG4gICAgICogICAgICdjb2xvcic6IC9cXGIoPzpyZWR8Z3JlZW58Ymx1ZSlcXGIvXG4gICAgICogfSk7XG4gICAgICovXG4gICAgZXh0ZW5kOiBmdW5jdGlvbiAoaWQsIHJlZGVmKSB7XG4gICAgICB2YXIgbGFuZyA9IF8udXRpbC5jbG9uZShfLmxhbmd1YWdlc1tpZF0pXG5cbiAgICAgIGZvciAodmFyIGtleSBpbiByZWRlZikge1xuICAgICAgICBsYW5nW2tleV0gPSByZWRlZltrZXldXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsYW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgdG9rZW5zIF9iZWZvcmVfIGFub3RoZXIgdG9rZW4gaW4gYSBsYW5ndWFnZSBkZWZpbml0aW9uIG9yIGFueSBvdGhlciBncmFtbWFyLlxuICAgICAqXG4gICAgICogIyMgVXNhZ2VcbiAgICAgKlxuICAgICAqIFRoaXMgaGVscGVyIG1ldGhvZCBtYWtlcyBpdCBlYXN5IHRvIG1vZGlmeSBleGlzdGluZyBsYW5ndWFnZXMuIEZvciBleGFtcGxlLCB0aGUgQ1NTIGxhbmd1YWdlIGRlZmluaXRpb25cbiAgICAgKiBub3Qgb25seSBkZWZpbmVzIENTUyBoaWdobGlnaHRpbmcgZm9yIENTUyBkb2N1bWVudHMsIGJ1dCBhbHNvIG5lZWRzIHRvIGRlZmluZSBoaWdobGlnaHRpbmcgZm9yIENTUyBlbWJlZGRlZFxuICAgICAqIGluIEhUTUwgdGhyb3VnaCBgPHN0eWxlPmAgZWxlbWVudHMuIFRvIGRvIHRoaXMsIGl0IG5lZWRzIHRvIG1vZGlmeSBgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cGAgYW5kIGFkZCB0aGVcbiAgICAgKiBhcHByb3ByaWF0ZSB0b2tlbnMuIEhvd2V2ZXIsIGBQcmlzbS5sYW5ndWFnZXMubWFya3VwYCBpcyBhIHJlZ3VsYXIgSmF2YVNjcmlwdCBvYmplY3QgbGl0ZXJhbCwgc28gaWYgeW91IGRvXG4gICAgICogdGhpczpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC5zdHlsZSA9IHtcbiAgICAgKiAgICAgLy8gdG9rZW5cbiAgICAgKiB9O1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogdGhlbiB0aGUgYHN0eWxlYCB0b2tlbiB3aWxsIGJlIGFkZGVkIChhbmQgcHJvY2Vzc2VkKSBhdCB0aGUgZW5kLiBgaW5zZXJ0QmVmb3JlYCBhbGxvd3MgeW91IHRvIGluc2VydCB0b2tlbnNcbiAgICAgKiBiZWZvcmUgZXhpc3RpbmcgdG9rZW5zLiBGb3IgdGhlIENTUyBleGFtcGxlIGFib3ZlLCB5b3Ugd291bGQgdXNlIGl0IGxpa2UgdGhpczpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ2NkYXRhJywge1xuICAgICAqICAgICAnc3R5bGUnOiB7XG4gICAgICogICAgICAgICAvLyB0b2tlblxuICAgICAqICAgICB9XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyBTcGVjaWFsIGNhc2VzXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZ3JhbW1hcnMgb2YgYGluc2lkZWAgYW5kIGBpbnNlcnRgIGhhdmUgdG9rZW5zIHdpdGggdGhlIHNhbWUgbmFtZSwgdGhlIHRva2VucyBpbiBgaW5zaWRlYCdzIGdyYW1tYXJcbiAgICAgKiB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIGJlaGF2aW9yIGNhbiBiZSB1c2VkIHRvIGluc2VydCB0b2tlbnMgYWZ0ZXIgYGJlZm9yZWA6XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICdjb21tZW50Jywge1xuICAgICAqICAgICAnY29tbWVudCc6IFByaXNtLmxhbmd1YWdlcy5tYXJrdXAuY29tbWVudCxcbiAgICAgKiAgICAgLy8gdG9rZW5zIGFmdGVyICdjb21tZW50J1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMgTGltaXRhdGlvbnNcbiAgICAgKlxuICAgICAqIFRoZSBtYWluIHByb2JsZW0gYGluc2VydEJlZm9yZWAgaGFzIHRvIHNvbHZlIGlzIGl0ZXJhdGlvbiBvcmRlci4gU2luY2UgRVMyMDE1LCB0aGUgaXRlcmF0aW9uIG9yZGVyIGZvciBvYmplY3RcbiAgICAgKiBwcm9wZXJ0aWVzIGlzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIGluc2VydGlvbiBvcmRlciAoZXhjZXB0IGZvciBpbnRlZ2VyIGtleXMpIGJ1dCBzb21lIGJyb3dzZXJzIGJlaGF2ZVxuICAgICAqIGRpZmZlcmVudGx5IHdoZW4ga2V5cyBhcmUgZGVsZXRlZCBhbmQgcmUtaW5zZXJ0ZWQuIFNvIGBpbnNlcnRCZWZvcmVgIGNhbid0IGJlIGltcGxlbWVudGVkIGJ5IHRlbXBvcmFyaWx5XG4gICAgICogZGVsZXRpbmcgcHJvcGVydGllcyB3aGljaCBpcyBuZWNlc3NhcnkgdG8gaW5zZXJ0IGF0IGFyYml0cmFyeSBwb3NpdGlvbnMuXG4gICAgICpcbiAgICAgKiBUbyBzb2x2ZSB0aGlzIHByb2JsZW0sIGBpbnNlcnRCZWZvcmVgIGRvZXNuJ3QgYWN0dWFsbHkgaW5zZXJ0IHRoZSBnaXZlbiB0b2tlbnMgaW50byB0aGUgdGFyZ2V0IG9iamVjdC5cbiAgICAgKiBJbnN0ZWFkLCBpdCB3aWxsIGNyZWF0ZSBhIG5ldyBvYmplY3QgYW5kIHJlcGxhY2UgYWxsIHJlZmVyZW5jZXMgdG8gdGhlIHRhcmdldCBvYmplY3Qgd2l0aCB0aGUgbmV3IG9uZS4gVGhpc1xuICAgICAqIGNhbiBiZSBkb25lIHdpdGhvdXQgdGVtcG9yYXJpbHkgZGVsZXRpbmcgcHJvcGVydGllcywgc28gdGhlIGl0ZXJhdGlvbiBvcmRlciBpcyB3ZWxsLWRlZmluZWQuXG4gICAgICpcbiAgICAgKiBIb3dldmVyLCBvbmx5IHJlZmVyZW5jZXMgdGhhdCBjYW4gYmUgcmVhY2hlZCBmcm9tIGBQcmlzbS5sYW5ndWFnZXNgIG9yIGBpbnNlcnRgIHdpbGwgYmUgcmVwbGFjZWQuIEkuZS4gaWZcbiAgICAgKiB5b3UgaG9sZCB0aGUgdGFyZ2V0IG9iamVjdCBpbiBhIHZhcmlhYmxlLCB0aGVuIHRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGUgd2lsbCBub3QgY2hhbmdlLlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiB2YXIgb2xkTWFya3VwID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcbiAgICAgKiB2YXIgbmV3TWFya3VwID0gUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ2NvbW1lbnQnLCB7IC4uLiB9KTtcbiAgICAgKlxuICAgICAqIGFzc2VydChvbGRNYXJrdXAgIT09IFByaXNtLmxhbmd1YWdlcy5tYXJrdXApO1xuICAgICAqIGFzc2VydChuZXdNYXJrdXAgPT09IFByaXNtLmxhbmd1YWdlcy5tYXJrdXApO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGluc2lkZSBUaGUgcHJvcGVydHkgb2YgYHJvb3RgIChlLmcuIGEgbGFuZ3VhZ2UgaWQgaW4gYFByaXNtLmxhbmd1YWdlc2ApIHRoYXQgY29udGFpbnMgdGhlXG4gICAgICogb2JqZWN0IHRvIGJlIG1vZGlmaWVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiZWZvcmUgVGhlIGtleSB0byBpbnNlcnQgYmVmb3JlLlxuICAgICAqIEBwYXJhbSB7R3JhbW1hcn0gaW5zZXJ0IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBrZXktdmFsdWUgcGFpcnMgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBbcm9vdF0gVGhlIG9iamVjdCBjb250YWluaW5nIGBpbnNpZGVgLCBpLmUuIHRoZSBvYmplY3QgdGhhdCBjb250YWlucyB0aGVcbiAgICAgKiBvYmplY3QgdG8gYmUgbW9kaWZpZWQuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0byBgUHJpc20ubGFuZ3VhZ2VzYC5cbiAgICAgKiBAcmV0dXJucyB7R3JhbW1hcn0gVGhlIG5ldyBncmFtbWFyIG9iamVjdC5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbiAoaW5zaWRlLCBiZWZvcmUsIGluc2VydCwgcm9vdCkge1xuICAgICAgcm9vdCA9IHJvb3QgfHwgLyoqIEB0eXBlIHthbnl9ICovIChfLmxhbmd1YWdlcylcbiAgICAgIHZhciBncmFtbWFyID0gcm9vdFtpbnNpZGVdXG4gICAgICAvKiogQHR5cGUge0dyYW1tYXJ9ICovXG4gICAgICB2YXIgcmV0ID0ge31cblxuICAgICAgZm9yICh2YXIgdG9rZW4gaW4gZ3JhbW1hcikge1xuICAgICAgICBpZiAoZ3JhbW1hci5oYXNPd25Qcm9wZXJ0eSh0b2tlbikpIHtcbiAgICAgICAgICBpZiAodG9rZW4gPT0gYmVmb3JlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuZXdUb2tlbiBpbiBpbnNlcnQpIHtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5oYXNPd25Qcm9wZXJ0eShuZXdUb2tlbikpIHtcbiAgICAgICAgICAgICAgICByZXRbbmV3VG9rZW5dID0gaW5zZXJ0W25ld1Rva2VuXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRG8gbm90IGluc2VydCB0b2tlbiB3aGljaCBhbHNvIG9jY3VyIGluIGluc2VydC4gU2VlICMxNTI1XG4gICAgICAgICAgaWYgKCFpbnNlcnQuaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XG4gICAgICAgICAgICByZXRbdG9rZW5dID0gZ3JhbW1hclt0b2tlbl1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG9sZCA9IHJvb3RbaW5zaWRlXVxuICAgICAgcm9vdFtpbnNpZGVdID0gcmV0XG5cbiAgICAgIC8vIFVwZGF0ZSByZWZlcmVuY2VzIGluIG90aGVyIGxhbmd1YWdlIGRlZmluaXRpb25zXG4gICAgICBfLmxhbmd1YWdlcy5ERlMoXy5sYW5ndWFnZXMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gb2xkICYmIGtleSAhPSBpbnNpZGUpIHtcbiAgICAgICAgICB0aGlzW2tleV0gPSByZXRcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHJldFxuICAgIH0sXG5cbiAgICAvLyBUcmF2ZXJzZSBhIGxhbmd1YWdlIGRlZmluaXRpb24gd2l0aCBEZXB0aCBGaXJzdCBTZWFyY2hcbiAgICBERlM6IGZ1bmN0aW9uIERGUyhvLCBjYWxsYmFjaywgdHlwZSwgdmlzaXRlZCkge1xuICAgICAgdmlzaXRlZCA9IHZpc2l0ZWQgfHwge31cblxuICAgICAgdmFyIG9iaklkID0gXy51dGlsLm9iaklkXG5cbiAgICAgIGZvciAodmFyIGkgaW4gbykge1xuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwobywgaSwgb1tpXSwgdHlwZSB8fCBpKVxuXG4gICAgICAgICAgdmFyIHByb3BlcnR5ID0gb1tpXVxuICAgICAgICAgIHZhciBwcm9wZXJ0eVR5cGUgPSBfLnV0aWwudHlwZShwcm9wZXJ0eSlcblxuICAgICAgICAgIGlmIChwcm9wZXJ0eVR5cGUgPT09ICdPYmplY3QnICYmICF2aXNpdGVkW29iaklkKHByb3BlcnR5KV0pIHtcbiAgICAgICAgICAgIHZpc2l0ZWRbb2JqSWQocHJvcGVydHkpXSA9IHRydWVcbiAgICAgICAgICAgIERGUyhwcm9wZXJ0eSwgY2FsbGJhY2ssIG51bGwsIHZpc2l0ZWQpXG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eVR5cGUgPT09ICdBcnJheScgJiYgIXZpc2l0ZWRbb2JqSWQocHJvcGVydHkpXSkge1xuICAgICAgICAgICAgdmlzaXRlZFtvYmpJZChwcm9wZXJ0eSldID0gdHJ1ZVxuICAgICAgICAgICAgREZTKHByb3BlcnR5LCBjYWxsYmFjaywgaSwgdmlzaXRlZClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcGx1Z2luczoge30sXG5cbiAgLyoqXG4gICAqIExvdy1sZXZlbCBmdW5jdGlvbiwgb25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3XigJlyZSBkb2luZy4gSXQgYWNjZXB0cyBhIHN0cmluZyBvZiB0ZXh0IGFzIGlucHV0XG4gICAqIGFuZCB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMgdG8gdXNlLCBhbmQgcmV0dXJucyBhIHN0cmluZyB3aXRoIHRoZSBIVE1MIHByb2R1Y2VkLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGhvb2tzIHdpbGwgYmUgcnVuOlxuICAgKiAxLiBgYmVmb3JlLXRva2VuaXplYFxuICAgKiAyLiBgYWZ0ZXItdG9rZW5pemVgXG4gICAqIDMuIGB3cmFwYDogT24gZWFjaCB7QGxpbmsgVG9rZW59LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBBIHN0cmluZyB3aXRoIHRoZSBjb2RlIHRvIGJlIGhpZ2hsaWdodGVkLlxuICAgKiBAcGFyYW0ge0dyYW1tYXJ9IGdyYW1tYXIgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHRva2VucyB0byB1c2UuXG4gICAqXG4gICAqIFVzdWFsbHkgYSBsYW5ndWFnZSBkZWZpbml0aW9uIGxpa2UgYFByaXNtLmxhbmd1YWdlcy5tYXJrdXBgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2UgVGhlIG5hbWUgb2YgdGhlIGxhbmd1YWdlIGRlZmluaXRpb24gcGFzc2VkIHRvIGBncmFtbWFyYC5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGhpZ2hsaWdodGVkIEhUTUwuXG4gICAqIEBtZW1iZXJvZiBQcmlzbVxuICAgKiBAcHVibGljXG4gICAqIEBleGFtcGxlXG4gICAqIFByaXNtLmhpZ2hsaWdodCgndmFyIGZvbyA9IHRydWU7JywgUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQsICdqYXZhc2NyaXB0Jyk7XG4gICAqL1xuICBoaWdobGlnaHQ6IGZ1bmN0aW9uICh0ZXh0LCBncmFtbWFyLCBsYW5ndWFnZSkge1xuICAgIHZhciBlbnYgPSB7XG4gICAgICBjb2RlOiB0ZXh0LFxuICAgICAgZ3JhbW1hcjogZ3JhbW1hcixcbiAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZVxuICAgIH1cbiAgICBfLmhvb2tzLnJ1bignYmVmb3JlLXRva2VuaXplJywgZW52KVxuICAgIGlmICghZW52LmdyYW1tYXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGxhbmd1YWdlIFwiJyArIGVudi5sYW5ndWFnZSArICdcIiBoYXMgbm8gZ3JhbW1hci4nKVxuICAgIH1cbiAgICBlbnYudG9rZW5zID0gXy50b2tlbml6ZShlbnYuY29kZSwgZW52LmdyYW1tYXIpXG4gICAgXy5ob29rcy5ydW4oJ2FmdGVyLXRva2VuaXplJywgZW52KVxuICAgIHJldHVybiBUb2tlbi5zdHJpbmdpZnkoXy51dGlsLmVuY29kZShlbnYudG9rZW5zKSwgZW52Lmxhbmd1YWdlKVxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBoZWFydCBvZiBQcmlzbSwgYW5kIHRoZSBtb3N0IGxvdy1sZXZlbCBmdW5jdGlvbiB5b3UgY2FuIHVzZS4gSXQgYWNjZXB0cyBhIHN0cmluZyBvZiB0ZXh0IGFzIGlucHV0XG4gICAqIGFuZCB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMgdG8gdXNlLCBhbmQgcmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSB0b2tlbml6ZWQgY29kZS5cbiAgICpcbiAgICogV2hlbiB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBpbmNsdWRlcyBuZXN0ZWQgdG9rZW5zLCB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIHJlY3Vyc2l2ZWx5IG9uIGVhY2ggb2YgdGhlc2UgdG9rZW5zLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBjb3VsZCBiZSB1c2VmdWwgaW4gb3RoZXIgY29udGV4dHMgYXMgd2VsbCwgYXMgYSB2ZXJ5IGNydWRlIHBhcnNlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgQSBzdHJpbmcgd2l0aCB0aGUgY29kZSB0byBiZSBoaWdobGlnaHRlZC5cbiAgICogQHBhcmFtIHtHcmFtbWFyfSBncmFtbWFyIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSB0b2tlbnMgdG8gdXNlLlxuICAgKlxuICAgKiBVc3VhbGx5IGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBsaWtlIGBQcmlzbS5sYW5ndWFnZXMubWFya3VwYC5cbiAgICogQHJldHVybnMge1Rva2VuU3RyZWFtfSBBbiBhcnJheSBvZiBzdHJpbmdzIGFuZCB0b2tlbnMsIGEgdG9rZW4gc3RyZWFtLlxuICAgKiBAbWVtYmVyb2YgUHJpc21cbiAgICogQHB1YmxpY1xuICAgKiBAZXhhbXBsZVxuICAgKiBsZXQgY29kZSA9IGB2YXIgZm9vID0gMDtgO1xuICAgKiBsZXQgdG9rZW5zID0gUHJpc20udG9rZW5pemUoY29kZSwgUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQpO1xuICAgKiB0b2tlbnMuZm9yRWFjaCh0b2tlbiA9PiB7XG4gICAqICAgICBpZiAodG9rZW4gaW5zdGFuY2VvZiBQcmlzbS5Ub2tlbiAmJiB0b2tlbi50eXBlID09PSAnbnVtYmVyJykge1xuICAgKiAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBudW1lcmljIGxpdGVyYWw6ICR7dG9rZW4uY29udGVudH1gKTtcbiAgICogICAgIH1cbiAgICogfSk7XG4gICAqL1xuICB0b2tlbml6ZTogZnVuY3Rpb24gKHRleHQsIGdyYW1tYXIpIHtcbiAgICB2YXIgcmVzdCA9IGdyYW1tYXIucmVzdFxuICAgIGlmIChyZXN0KSB7XG4gICAgICBmb3IgKHZhciB0b2tlbiBpbiByZXN0KSB7XG4gICAgICAgIGdyYW1tYXJbdG9rZW5dID0gcmVzdFt0b2tlbl1cbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGdyYW1tYXIucmVzdFxuICAgIH1cblxuICAgIHZhciB0b2tlbkxpc3QgPSBuZXcgTGlua2VkTGlzdCgpXG4gICAgYWRkQWZ0ZXIodG9rZW5MaXN0LCB0b2tlbkxpc3QuaGVhZCwgdGV4dClcblxuICAgIG1hdGNoR3JhbW1hcih0ZXh0LCB0b2tlbkxpc3QsIGdyYW1tYXIsIHRva2VuTGlzdC5oZWFkLCAwKVxuXG4gICAgcmV0dXJuIHRvQXJyYXkodG9rZW5MaXN0KVxuICB9LFxuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBtZW1iZXJvZiBQcmlzbVxuICAgKiBAcHVibGljXG4gICAqL1xuICBob29rczoge1xuICAgIGFsbDoge30sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiBjYWxsYmFjayB0byB0aGUgbGlzdCBvZiBjYWxsYmFja3MgZm9yIHRoZSBnaXZlbiBob29rLlxuICAgICAqXG4gICAgICogVGhlIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCB3aGVuIHRoZSBob29rIGl0IGlzIHJlZ2lzdGVyZWQgZm9yIGlzIHJ1bi5cbiAgICAgKiBIb29rcyBhcmUgdXN1YWxseSBkaXJlY3RseSBydW4gYnkgYSBoaWdobGlnaHQgZnVuY3Rpb24gYnV0IHlvdSBjYW4gYWxzbyBydW4gaG9va3MgeW91cnNlbGYuXG4gICAgICpcbiAgICAgKiBPbmUgY2FsbGJhY2sgZnVuY3Rpb24gY2FuIGJlIHJlZ2lzdGVyZWQgdG8gbXVsdGlwbGUgaG9va3MgYW5kIHRoZSBzYW1lIGhvb2sgbXVsdGlwbGUgdGltZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9vay5cbiAgICAgKiBAcGFyYW0ge0hvb2tDYWxsYmFja30gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIGlzIGdpdmVuIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBob29rcyA9IF8uaG9va3MuYWxsXG5cbiAgICAgIGhvb2tzW25hbWVdID0gaG9va3NbbmFtZV0gfHwgW11cblxuICAgICAgaG9va3NbbmFtZV0ucHVzaChjYWxsYmFjaylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUnVucyBhIGhvb2sgaW52b2tpbmcgYWxsIHJlZ2lzdGVyZWQgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAgICAgKlxuICAgICAqIENhbGxiYWNrcyB3aWxsIGJlIGludm9rZWQgc3luY2hyb25vdXNseSBhbmQgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgd2VyZSByZWdpc3RlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGhvb2suXG4gICAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBlbnYgVGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyBvZiB0aGUgaG9vayBwYXNzZWQgdG8gYWxsIGNhbGxiYWNrcyByZWdpc3RlcmVkLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBydW46IGZ1bmN0aW9uIChuYW1lLCBlbnYpIHtcbiAgICAgIHZhciBjYWxsYmFja3MgPSBfLmhvb2tzLmFsbFtuYW1lXVxuXG4gICAgICBpZiAoIWNhbGxiYWNrcyB8fCAhY2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGNhbGxiYWNrOyAoY2FsbGJhY2sgPSBjYWxsYmFja3NbaSsrXSk7ICkge1xuICAgICAgICBjYWxsYmFjayhlbnYpXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIFRva2VuOiBUb2tlblxufVxuXG4vLyBUeXBlc2NyaXB0IG5vdGU6XG4vLyBUaGUgZm9sbG93aW5nIGNhbiBiZSB1c2VkIHRvIGltcG9ydCB0aGUgVG9rZW4gdHlwZSBpbiBKU0RvYzpcbi8vXG4vLyAgIEB0eXBlZGVmIHtJbnN0YW5jZVR5cGU8aW1wb3J0KFwiLi9wcmlzbS1jb3JlXCIpW1wiVG9rZW5cIl0+fSBUb2tlblxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdG9rZW4uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgU2VlIHtAbGluayBUb2tlbiN0eXBlIHR5cGV9XG4gKiBAcGFyYW0ge3N0cmluZyB8IFRva2VuU3RyZWFtfSBjb250ZW50IFNlZSB7QGxpbmsgVG9rZW4jY29udGVudCBjb250ZW50fVxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFthbGlhc10gVGhlIGFsaWFzKGVzKSBvZiB0aGUgdG9rZW4uXG4gKiBAcGFyYW0ge3N0cmluZ30gW21hdGNoZWRTdHI9XCJcIl0gQSBjb3B5IG9mIHRoZSBmdWxsIHN0cmluZyB0aGlzIHRva2VuIHdhcyBjcmVhdGVkIGZyb20uXG4gKiBAY2xhc3NcbiAqIEBnbG9iYWxcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gVG9rZW4odHlwZSwgY29udGVudCwgYWxpYXMsIG1hdGNoZWRTdHIpIHtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSB0b2tlbi5cbiAgICpcbiAgICogVGhpcyBpcyB1c3VhbGx5IHRoZSBrZXkgb2YgYSBwYXR0ZXJuIGluIGEge0BsaW5rIEdyYW1tYXJ9LlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAc2VlIEdyYW1tYXJUb2tlblxuICAgKiBAcHVibGljXG4gICAqL1xuICB0aGlzLnR5cGUgPSB0eXBlXG4gIC8qKlxuICAgKiBUaGUgc3RyaW5ncyBvciB0b2tlbnMgY29udGFpbmVkIGJ5IHRoaXMgdG9rZW4uXG4gICAqXG4gICAqIFRoaXMgd2lsbCBiZSBhIHRva2VuIHN0cmVhbSBpZiB0aGUgcGF0dGVybiBtYXRjaGVkIGFsc28gZGVmaW5lZCBhbiBgaW5zaWRlYCBncmFtbWFyLlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nIHwgVG9rZW5TdHJlYW19XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRoaXMuY29udGVudCA9IGNvbnRlbnRcbiAgLyoqXG4gICAqIFRoZSBhbGlhcyhlcykgb2YgdGhlIHRva2VuLlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfHN0cmluZ1tdfVxuICAgKiBAc2VlIEdyYW1tYXJUb2tlblxuICAgKiBAcHVibGljXG4gICAqL1xuICB0aGlzLmFsaWFzID0gYWxpYXNcbiAgLy8gQ29weSBvZiB0aGUgZnVsbCBzdHJpbmcgdGhpcyB0b2tlbiB3YXMgY3JlYXRlZCBmcm9tXG4gIHRoaXMubGVuZ3RoID0gKG1hdGNoZWRTdHIgfHwgJycpLmxlbmd0aCB8IDBcbn1cblxuLyoqXG4gKiBBIHRva2VuIHN0cmVhbSBpcyBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCB7QGxpbmsgVG9rZW4gVG9rZW59IG9iamVjdHMuXG4gKlxuICogVG9rZW4gc3RyZWFtcyBoYXZlIHRvIGZ1bGZpbGwgYSBmZXcgcHJvcGVydGllcyB0aGF0IGFyZSBhc3N1bWVkIGJ5IG1vc3QgZnVuY3Rpb25zIChtb3N0bHkgaW50ZXJuYWwgb25lcykgdGhhdCBwcm9jZXNzXG4gKiB0aGVtLlxuICpcbiAqIDEuIE5vIGFkamFjZW50IHN0cmluZ3MuXG4gKiAyLiBObyBlbXB0eSBzdHJpbmdzLlxuICpcbiAqICAgIFRoZSBvbmx5IGV4Y2VwdGlvbiBoZXJlIGlzIHRoZSB0b2tlbiBzdHJlYW0gdGhhdCBvbmx5IGNvbnRhaW5zIHRoZSBlbXB0eSBzdHJpbmcgYW5kIG5vdGhpbmcgZWxzZS5cbiAqXG4gKiBAdHlwZWRlZiB7QXJyYXk8c3RyaW5nIHwgVG9rZW4+fSBUb2tlblN0cmVhbVxuICogQGdsb2JhbFxuICogQHB1YmxpY1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtSZWdFeHB9IHBhdHRlcm5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3NcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvb2tiZWhpbmRcbiAqIEByZXR1cm5zIHtSZWdFeHBFeGVjQXJyYXkgfCBudWxsfVxuICovXG5mdW5jdGlvbiBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcG9zLCB0ZXh0LCBsb29rYmVoaW5kKSB7XG4gIHBhdHRlcm4ubGFzdEluZGV4ID0gcG9zXG4gIHZhciBtYXRjaCA9IHBhdHRlcm4uZXhlYyh0ZXh0KVxuICBpZiAobWF0Y2ggJiYgbG9va2JlaGluZCAmJiBtYXRjaFsxXSkge1xuICAgIC8vIGNoYW5nZSB0aGUgbWF0Y2ggdG8gcmVtb3ZlIHRoZSB0ZXh0IG1hdGNoZWQgYnkgdGhlIFByaXNtIGxvb2tiZWhpbmQgZ3JvdXBcbiAgICB2YXIgbG9va2JlaGluZExlbmd0aCA9IG1hdGNoWzFdLmxlbmd0aFxuICAgIG1hdGNoLmluZGV4ICs9IGxvb2tiZWhpbmRMZW5ndGhcbiAgICBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKGxvb2tiZWhpbmRMZW5ndGgpXG4gIH1cbiAgcmV0dXJuIG1hdGNoXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7TGlua2VkTGlzdDxzdHJpbmcgfCBUb2tlbj59IHRva2VuTGlzdFxuICogQHBhcmFtIHthbnl9IGdyYW1tYXJcbiAqIEBwYXJhbSB7TGlua2VkTGlzdE5vZGU8c3RyaW5nIHwgVG9rZW4+fSBzdGFydE5vZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFBvc1xuICogQHBhcmFtIHtSZW1hdGNoT3B0aW9uc30gW3JlbWF0Y2hdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKlxuICogQHR5cGVkZWYgUmVtYXRjaE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjYXVzZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJlYWNoXG4gKi9cbmZ1bmN0aW9uIG1hdGNoR3JhbW1hcih0ZXh0LCB0b2tlbkxpc3QsIGdyYW1tYXIsIHN0YXJ0Tm9kZSwgc3RhcnRQb3MsIHJlbWF0Y2gpIHtcbiAgZm9yICh2YXIgdG9rZW4gaW4gZ3JhbW1hcikge1xuICAgIGlmICghZ3JhbW1hci5oYXNPd25Qcm9wZXJ0eSh0b2tlbikgfHwgIWdyYW1tYXJbdG9rZW5dKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHZhciBwYXR0ZXJucyA9IGdyYW1tYXJbdG9rZW5dXG4gICAgcGF0dGVybnMgPSBBcnJheS5pc0FycmF5KHBhdHRlcm5zKSA/IHBhdHRlcm5zIDogW3BhdHRlcm5zXVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXR0ZXJucy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKHJlbWF0Y2ggJiYgcmVtYXRjaC5jYXVzZSA9PSB0b2tlbiArICcsJyArIGopIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHZhciBwYXR0ZXJuT2JqID0gcGF0dGVybnNbal1cbiAgICAgIHZhciBpbnNpZGUgPSBwYXR0ZXJuT2JqLmluc2lkZVxuICAgICAgdmFyIGxvb2tiZWhpbmQgPSAhIXBhdHRlcm5PYmoubG9va2JlaGluZFxuICAgICAgdmFyIGdyZWVkeSA9ICEhcGF0dGVybk9iai5ncmVlZHlcbiAgICAgIHZhciBhbGlhcyA9IHBhdHRlcm5PYmouYWxpYXNcblxuICAgICAgaWYgKGdyZWVkeSAmJiAhcGF0dGVybk9iai5wYXR0ZXJuLmdsb2JhbCkge1xuICAgICAgICAvLyBXaXRob3V0IHRoZSBnbG9iYWwgZmxhZywgbGFzdEluZGV4IHdvbid0IHdvcmtcbiAgICAgICAgdmFyIGZsYWdzID0gcGF0dGVybk9iai5wYXR0ZXJuLnRvU3RyaW5nKCkubWF0Y2goL1tpbXN1eV0qJC8pWzBdXG4gICAgICAgIHBhdHRlcm5PYmoucGF0dGVybiA9IFJlZ0V4cChwYXR0ZXJuT2JqLnBhdHRlcm4uc291cmNlLCBmbGFncyArICdnJylcbiAgICAgIH1cblxuICAgICAgLyoqIEB0eXBlIHtSZWdFeHB9ICovXG4gICAgICB2YXIgcGF0dGVybiA9IHBhdHRlcm5PYmoucGF0dGVybiB8fCBwYXR0ZXJuT2JqXG5cbiAgICAgIGZvciAoXG4gICAgICAgIC8vIGl0ZXJhdGUgdGhlIHRva2VuIGxpc3QgYW5kIGtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgdG9rZW4vc3RyaW5nIHBvc2l0aW9uXG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHN0YXJ0Tm9kZS5uZXh0LCBwb3MgPSBzdGFydFBvcztcbiAgICAgICAgY3VycmVudE5vZGUgIT09IHRva2VuTGlzdC50YWlsO1xuICAgICAgICBwb3MgKz0gY3VycmVudE5vZGUudmFsdWUubGVuZ3RoLCBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHRcbiAgICAgICkge1xuICAgICAgICBpZiAocmVtYXRjaCAmJiBwb3MgPj0gcmVtYXRjaC5yZWFjaCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RyID0gY3VycmVudE5vZGUudmFsdWVcblxuICAgICAgICBpZiAodG9rZW5MaXN0Lmxlbmd0aCA+IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgdGVycmlibHkgd3JvbmcsIEFCT1JULCBBQk9SVCFcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHIgaW5zdGFuY2VvZiBUb2tlbikge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVtb3ZlQ291bnQgPSAxIC8vIHRoaXMgaXMgdGhlIHRvIHBhcmFtZXRlciBvZiByZW1vdmVCZXR3ZWVuXG4gICAgICAgIHZhciBtYXRjaFxuXG4gICAgICAgIGlmIChncmVlZHkpIHtcbiAgICAgICAgICBtYXRjaCA9IG1hdGNoUGF0dGVybihwYXR0ZXJuLCBwb3MsIHRleHQsIGxvb2tiZWhpbmQpXG4gICAgICAgICAgaWYgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCA+PSB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZnJvbSA9IG1hdGNoLmluZGV4XG4gICAgICAgICAgdmFyIHRvID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgICB2YXIgcCA9IHBvc1xuXG4gICAgICAgICAgLy8gZmluZCB0aGUgbm9kZSB0aGF0IGNvbnRhaW5zIHRoZSBtYXRjaFxuICAgICAgICAgIHAgKz0gY3VycmVudE5vZGUudmFsdWUubGVuZ3RoXG4gICAgICAgICAgd2hpbGUgKGZyb20gPj0gcCkge1xuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0XG4gICAgICAgICAgICBwICs9IGN1cnJlbnROb2RlLnZhbHVlLmxlbmd0aFxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBhZGp1c3QgcG9zIChhbmQgcClcbiAgICAgICAgICBwIC09IGN1cnJlbnROb2RlLnZhbHVlLmxlbmd0aFxuICAgICAgICAgIHBvcyA9IHBcblxuICAgICAgICAgIC8vIHRoZSBjdXJyZW50IG5vZGUgaXMgYSBUb2tlbiwgdGhlbiB0aGUgbWF0Y2ggc3RhcnRzIGluc2lkZSBhbm90aGVyIFRva2VuLCB3aGljaCBpcyBpbnZhbGlkXG4gICAgICAgICAgaWYgKGN1cnJlbnROb2RlLnZhbHVlIGluc3RhbmNlb2YgVG9rZW4pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZmluZCB0aGUgbGFzdCBub2RlIHdoaWNoIGlzIGFmZmVjdGVkIGJ5IHRoaXMgbWF0Y2hcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgdmFyIGsgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgICAgIGsgIT09IHRva2VuTGlzdC50YWlsICYmIChwIDwgdG8gfHwgdHlwZW9mIGsudmFsdWUgPT09ICdzdHJpbmcnKTtcbiAgICAgICAgICAgIGsgPSBrLm5leHRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJlbW92ZUNvdW50KytcbiAgICAgICAgICAgIHAgKz0gay52YWx1ZS5sZW5ndGhcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVtb3ZlQ291bnQtLVxuXG4gICAgICAgICAgLy8gcmVwbGFjZSB3aXRoIHRoZSBuZXcgbWF0Y2hcbiAgICAgICAgICBzdHIgPSB0ZXh0LnNsaWNlKHBvcywgcClcbiAgICAgICAgICBtYXRjaC5pbmRleCAtPSBwb3NcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaCA9IG1hdGNoUGF0dGVybihwYXR0ZXJuLCAwLCBzdHIsIGxvb2tiZWhpbmQpXG4gICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG4gICAgICAgIHZhciBmcm9tID0gbWF0Y2guaW5kZXhcbiAgICAgICAgdmFyIG1hdGNoU3RyID0gbWF0Y2hbMF1cbiAgICAgICAgdmFyIGJlZm9yZSA9IHN0ci5zbGljZSgwLCBmcm9tKVxuICAgICAgICB2YXIgYWZ0ZXIgPSBzdHIuc2xpY2UoZnJvbSArIG1hdGNoU3RyLmxlbmd0aClcblxuICAgICAgICB2YXIgcmVhY2ggPSBwb3MgKyBzdHIubGVuZ3RoXG4gICAgICAgIGlmIChyZW1hdGNoICYmIHJlYWNoID4gcmVtYXRjaC5yZWFjaCkge1xuICAgICAgICAgIHJlbWF0Y2gucmVhY2ggPSByZWFjaFxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbW92ZUZyb20gPSBjdXJyZW50Tm9kZS5wcmV2XG5cbiAgICAgICAgaWYgKGJlZm9yZSkge1xuICAgICAgICAgIHJlbW92ZUZyb20gPSBhZGRBZnRlcih0b2tlbkxpc3QsIHJlbW92ZUZyb20sIGJlZm9yZSlcbiAgICAgICAgICBwb3MgKz0gYmVmb3JlLmxlbmd0aFxuICAgICAgICB9XG5cbiAgICAgICAgcmVtb3ZlUmFuZ2UodG9rZW5MaXN0LCByZW1vdmVGcm9tLCByZW1vdmVDb3VudClcblxuICAgICAgICB2YXIgd3JhcHBlZCA9IG5ldyBUb2tlbihcbiAgICAgICAgICB0b2tlbixcbiAgICAgICAgICBpbnNpZGUgPyBfLnRva2VuaXplKG1hdGNoU3RyLCBpbnNpZGUpIDogbWF0Y2hTdHIsXG4gICAgICAgICAgYWxpYXMsXG4gICAgICAgICAgbWF0Y2hTdHJcbiAgICAgICAgKVxuICAgICAgICBjdXJyZW50Tm9kZSA9IGFkZEFmdGVyKHRva2VuTGlzdCwgcmVtb3ZlRnJvbSwgd3JhcHBlZClcblxuICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICBhZGRBZnRlcih0b2tlbkxpc3QsIGN1cnJlbnROb2RlLCBhZnRlcilcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW1vdmVDb3VudCA+IDEpIHtcbiAgICAgICAgICAvLyBhdCBsZWFzdCBvbmUgVG9rZW4gb2JqZWN0IHdhcyByZW1vdmVkLCBzbyB3ZSBoYXZlIHRvIGRvIHNvbWUgcmVtYXRjaGluZ1xuICAgICAgICAgIC8vIHRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBjdXJyZW50IHBhdHRlcm4gaXMgZ3JlZWR5XG5cbiAgICAgICAgICAvKiogQHR5cGUge1JlbWF0Y2hPcHRpb25zfSAqL1xuICAgICAgICAgIHZhciBuZXN0ZWRSZW1hdGNoID0ge1xuICAgICAgICAgICAgY2F1c2U6IHRva2VuICsgJywnICsgaixcbiAgICAgICAgICAgIHJlYWNoOiByZWFjaFxuICAgICAgICAgIH1cbiAgICAgICAgICBtYXRjaEdyYW1tYXIoXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgdG9rZW5MaXN0LFxuICAgICAgICAgICAgZ3JhbW1hcixcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLnByZXYsXG4gICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICBuZXN0ZWRSZW1hdGNoXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgLy8gdGhlIHJlYWNoIG1pZ2h0IGhhdmUgYmVlbiBleHRlbmRlZCBiZWNhdXNlIG9mIHRoZSByZW1hdGNoaW5nXG4gICAgICAgICAgaWYgKHJlbWF0Y2ggJiYgbmVzdGVkUmVtYXRjaC5yZWFjaCA+IHJlbWF0Y2gucmVhY2gpIHtcbiAgICAgICAgICAgIHJlbWF0Y2gucmVhY2ggPSBuZXN0ZWRSZW1hdGNoLnJlYWNoXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYgTGlua2VkTGlzdE5vZGVcbiAqIEBwcm9wZXJ0eSB7VH0gdmFsdWVcbiAqIEBwcm9wZXJ0eSB7TGlua2VkTGlzdE5vZGU8VD4gfCBudWxsfSBwcmV2IFRoZSBwcmV2aW91cyBub2RlLlxuICogQHByb3BlcnR5IHtMaW5rZWRMaXN0Tm9kZTxUPiB8IG51bGx9IG5leHQgVGhlIG5leHQgbm9kZS5cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcHJpdmF0ZVxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIExpbmtlZExpc3QoKSB7XG4gIC8qKiBAdHlwZSB7TGlua2VkTGlzdE5vZGU8VD59ICovXG4gIHZhciBoZWFkID0ge3ZhbHVlOiBudWxsLCBwcmV2OiBudWxsLCBuZXh0OiBudWxsfVxuICAvKiogQHR5cGUge0xpbmtlZExpc3ROb2RlPFQ+fSAqL1xuICB2YXIgdGFpbCA9IHt2YWx1ZTogbnVsbCwgcHJldjogaGVhZCwgbmV4dDogbnVsbH1cbiAgaGVhZC5uZXh0ID0gdGFpbFxuXG4gIC8qKiBAdHlwZSB7TGlua2VkTGlzdE5vZGU8VD59ICovXG4gIHRoaXMuaGVhZCA9IGhlYWRcbiAgLyoqIEB0eXBlIHtMaW5rZWRMaXN0Tm9kZTxUPn0gKi9cbiAgdGhpcy50YWlsID0gdGFpbFxuICB0aGlzLmxlbmd0aCA9IDBcbn1cblxuLyoqXG4gKiBBZGRzIGEgbmV3IG5vZGUgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhlIGxpc3QuXG4gKlxuICogQHBhcmFtIHtMaW5rZWRMaXN0PFQ+fSBsaXN0XG4gKiBAcGFyYW0ge0xpbmtlZExpc3ROb2RlPFQ+fSBub2RlXG4gKiBAcGFyYW0ge1R9IHZhbHVlXG4gKiBAcmV0dXJucyB7TGlua2VkTGlzdE5vZGU8VD59IFRoZSBhZGRlZCBub2RlLlxuICogQHRlbXBsYXRlIFRcbiAqL1xuZnVuY3Rpb24gYWRkQWZ0ZXIobGlzdCwgbm9kZSwgdmFsdWUpIHtcbiAgLy8gYXNzdW1lcyB0aGF0IG5vZGUgIT0gbGlzdC50YWlsICYmIHZhbHVlcy5sZW5ndGggPj0gMFxuICB2YXIgbmV4dCA9IG5vZGUubmV4dFxuXG4gIHZhciBuZXdOb2RlID0ge3ZhbHVlOiB2YWx1ZSwgcHJldjogbm9kZSwgbmV4dDogbmV4dH1cbiAgbm9kZS5uZXh0ID0gbmV3Tm9kZVxuICBuZXh0LnByZXYgPSBuZXdOb2RlXG4gIGxpc3QubGVuZ3RoKytcblxuICByZXR1cm4gbmV3Tm9kZVxufVxuLyoqXG4gKiBSZW1vdmVzIGBjb3VudGAgbm9kZXMgYWZ0ZXIgdGhlIGdpdmVuIG5vZGUuIFRoZSBnaXZlbiBub2RlIHdpbGwgbm90IGJlIHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtMaW5rZWRMaXN0PFQ+fSBsaXN0XG4gKiBAcGFyYW0ge0xpbmtlZExpc3ROb2RlPFQ+fSBub2RlXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZVJhbmdlKGxpc3QsIG5vZGUsIGNvdW50KSB7XG4gIHZhciBuZXh0ID0gbm9kZS5uZXh0XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgJiYgbmV4dCAhPT0gbGlzdC50YWlsOyBpKyspIHtcbiAgICBuZXh0ID0gbmV4dC5uZXh0XG4gIH1cbiAgbm9kZS5uZXh0ID0gbmV4dFxuICBuZXh0LnByZXYgPSBub2RlXG4gIGxpc3QubGVuZ3RoIC09IGlcbn1cbi8qKlxuICogQHBhcmFtIHtMaW5rZWRMaXN0PFQ+fSBsaXN0XG4gKiBAcmV0dXJucyB7VFtdfVxuICogQHRlbXBsYXRlIFRcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShsaXN0KSB7XG4gIHZhciBhcnJheSA9IFtdXG4gIHZhciBub2RlID0gbGlzdC5oZWFkLm5leHRcbiAgd2hpbGUgKG5vZGUgIT09IGxpc3QudGFpbCkge1xuICAgIGFycmF5LnB1c2gobm9kZS52YWx1ZSlcbiAgICBub2RlID0gbm9kZS5uZXh0XG4gIH1cbiAgcmV0dXJuIGFycmF5XG59XG5cbmV4cG9ydCBjb25zdCBQcmlzbSA9IF9cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/refractor/lib/prism-core.js\n");

/***/ })

};
;